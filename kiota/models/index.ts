/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { type AdditionalDataHolder, type DateOnly, type Duration, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface Attachment extends Entity, Parsable {
    /**
     * The MIME type.
     */
    contentType?: string;
    /**
     * true if the attachment is an inline attachment; otherwise, false.
     */
    isInline?: boolean;
    /**
     * The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    lastModifiedDateTime?: Date;
    /**
     * The attachment's file name.
     */
    name?: string;
    /**
     * The length of the attachment in bytes.
     */
    size?: number;
}
export interface Attendee extends AttendeeBase, Parsable {
    /**
     * An alternate date/time proposed by the attendee for a meeting request to start and end. If the attendee hasn't proposed another time, then this property isn't included in a response of a GET event.
     */
    proposedNewTime?: TimeSlot;
    /**
     * The attendee's response (none, accepted, declined, etc.) for the event and date-time that the response was sent.
     */
    status?: ResponseStatus;
}
export interface AttendeeBase extends Parsable, Recipient {
    /**
     * The type of attendee. The possible values are: required, optional, resource. Currently if the attendee is a person, findMeetingTimes always considers the person is of the Required type.
     */
    type?: AttendeeType;
}
export type AttendeeType = (typeof AttendeeTypeObject)[keyof typeof AttendeeTypeObject];
export interface AzureCommunicationServicesUserIdentity extends Identity, Parsable {
    /**
     * The Azure Communication Services resource ID associated with the user.
     */
    azureCommunicationServicesResourceId?: string;
}
export interface BaseCollectionPaginationCountResponse extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataCount property
     */
    odataCount?: number;
    /**
     * The OdataNextLink property
     */
    odataNextLink?: string;
}
export interface BaseDeltaFunctionResponse extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataDeltaLink property
     */
    odataDeltaLink?: string;
    /**
     * The OdataNextLink property
     */
    odataNextLink?: string;
}
export type BodyType = (typeof BodyTypeObject)[keyof typeof BodyTypeObject];
export interface Calendar extends Entity, Parsable {
    /**
     * Represent the online meeting service providers that can be used to create online meetings in this calendar. Possible values are: unknown, skypeForBusiness, skypeForConsumer, teamsForBusiness.
     */
    allowedOnlineMeetingProviders?: OnlineMeetingProviderType[];
    /**
     * The permissions of the users with whom the calendar is shared.
     */
    calendarPermissions?: CalendarPermission[];
    /**
     * The calendar view for the calendar. Navigation property. Read-only.
     */
    calendarView?: Event[];
    /**
     * true if the user can write to the calendar, false otherwise. This property is true for the user who created the calendar. This property is also true for a user who has been shared a calendar and granted write access.
     */
    canEdit?: boolean;
    /**
     * true if the user has the permission to share the calendar, false otherwise. Only the user who created the calendar can share it.
     */
    canShare?: boolean;
    /**
     * true if the user can read calendar items that have been marked private, false otherwise.
     */
    canViewPrivateItems?: boolean;
    /**
     * Identifies the version of the calendar object. Every time the calendar is changed, changeKey changes as well. This allows Exchange to apply changes to the correct version of the object. Read-only.
     */
    changeKey?: string;
    /**
     * Specifies the color theme to distinguish the calendar from other calendars in a UI. The property values are: auto, lightBlue, lightGreen, lightOrange, lightGray, lightYellow, lightTeal, lightPink, lightBrown, lightRed, maxColor.
     */
    color?: CalendarColor;
    /**
     * The default online meeting provider for meetings sent from this calendar. Possible values are: unknown, skypeForBusiness, skypeForConsumer, teamsForBusiness.
     */
    defaultOnlineMeetingProvider?: OnlineMeetingProviderType;
    /**
     * The events in the calendar. Navigation property. Read-only.
     */
    events?: Event[];
    /**
     * The calendar color, expressed in a hex color code of three hexadecimal values, each ranging from 00 to FF and representing the red, green, or blue components of the color in the RGB color space. If the user has never explicitly set a color for the calendar, this property is empty. Read-only.
     */
    hexColor?: string;
    /**
     * true if this is the default calendar where new events are created by default, false otherwise.
     */
    isDefaultCalendar?: boolean;
    /**
     * Indicates whether this user calendar can be deleted from the user mailbox.
     */
    isRemovable?: boolean;
    /**
     * Indicates whether this user calendar supports tracking of meeting responses. Only meeting invites sent from users' primary calendars support tracking of meeting responses.
     */
    isTallyingResponses?: boolean;
    /**
     * The collection of multi-value extended properties defined for the calendar. Read-only. Nullable.
     */
    multiValueExtendedProperties?: MultiValueLegacyExtendedProperty[];
    /**
     * The calendar name.
     */
    name?: string;
    /**
     * If set, this represents the user who created or added the calendar. For a calendar that the user created or added, the owner property is set to the user. For a calendar shared with the user, the owner property is set to the person who shared that calendar with the user.
     */
    owner?: EmailAddress;
    /**
     * The collection of single-value extended properties defined for the calendar. Read-only. Nullable.
     */
    singleValueExtendedProperties?: SingleValueLegacyExtendedProperty[];
}
export type CalendarColor = (typeof CalendarColorObject)[keyof typeof CalendarColorObject];
export interface CalendarPermission extends Entity, Parsable {
    /**
     * List of allowed sharing or delegating permission levels for the calendar. Possible values are: none, freeBusyRead, limitedRead, read, write, delegateWithoutPrivateEventAccess, delegateWithPrivateEventAccess, custom.
     */
    allowedRoles?: CalendarRoleType[];
    /**
     * Represents a share recipient or delegate who has access to the calendar. For the 'My Organization' share recipient, the address property is null. Read-only.
     */
    emailAddress?: EmailAddress;
    /**
     * True if the user in context (recipient or delegate) is inside the same organization as the calendar owner.
     */
    isInsideOrganization?: boolean;
    /**
     * True if the user can be removed from the list of recipients or delegates for the specified calendar, false otherwise. The 'My organization' user determines the permissions other people within your organization have to the given calendar. You can't remove 'My organization' as a share recipient to a calendar.
     */
    isRemovable?: boolean;
    /**
     * Current permission level of the calendar share recipient or delegate.
     */
    role?: CalendarRoleType;
}
export type CalendarRoleType = (typeof CalendarRoleTypeObject)[keyof typeof CalendarRoleTypeObject];
export type CalendarSharingAction = (typeof CalendarSharingActionObject)[keyof typeof CalendarSharingActionObject];
export type CalendarSharingActionImportance = (typeof CalendarSharingActionImportanceObject)[keyof typeof CalendarSharingActionImportanceObject];
export type CalendarSharingActionType = (typeof CalendarSharingActionTypeObject)[keyof typeof CalendarSharingActionTypeObject];
export interface CalendarSharingMessage extends Message, Parsable {
    /**
     * The canAccept property
     */
    canAccept?: boolean;
    /**
     * The sharingMessageAction property
     */
    sharingMessageAction?: CalendarSharingMessageAction;
    /**
     * The sharingMessageActions property
     */
    sharingMessageActions?: CalendarSharingMessageAction[];
    /**
     * The suggestedCalendarName property
     */
    suggestedCalendarName?: string;
}
export interface CalendarSharingMessageAction extends AdditionalDataHolder, Parsable {
    /**
     * The action property
     */
    action?: CalendarSharingAction;
    /**
     * The actionType property
     */
    actionType?: CalendarSharingActionType;
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The importance property
     */
    importance?: CalendarSharingActionImportance;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface CallEndedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Duration of the call.
     */
    callDuration?: Duration;
    /**
     * Represents the call event type. Possible values are: call, meeting, screenShare, unknownFutureValue.
     */
    callEventType?: TeamworkCallEventType;
    /**
     * Unique identifier of the call.
     */
    callId?: string;
    /**
     * List of call participants.
     */
    callParticipants?: CallParticipantInfo[];
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
}
export interface CallParticipantInfo extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Identity of the call participant.
     */
    participant?: IdentitySet;
}
export interface CallRecordingEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Unique identifier of the call.
     */
    callId?: string;
    /**
     * Display name for the call recording.
     */
    callRecordingDisplayName?: string;
    /**
     * Duration of the call recording.
     */
    callRecordingDuration?: Duration;
    /**
     * Status of the call recording. Possible values are: success, failure, initial, chunkFinished, unknownFutureValue.
     */
    callRecordingStatus?: CallRecordingStatus;
    /**
     * Call recording URL.
     */
    callRecordingUrl?: string;
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
    /**
     * Organizer of the meeting.
     */
    meetingOrganizer?: IdentitySet;
}
export type CallRecordingStatus = (typeof CallRecordingStatusObject)[keyof typeof CallRecordingStatusObject];
export interface CallStartedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Represents the call event type. Possible values are: call, meeting, screenShare, unknownFutureValue.
     */
    callEventType?: TeamworkCallEventType;
    /**
     * Unique identifier of the call.
     */
    callId?: string;
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
}
export interface CallTranscriptEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Unique identifier of the call.
     */
    callId?: string;
    /**
     * Unique identifier for a call transcript.
     */
    callTranscriptICalUid?: string;
    /**
     * The organizer of the meeting.
     */
    meetingOrganizer?: IdentitySet;
}
export interface ChannelAddedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Display name of the channel.
     */
    channelDisplayName?: string;
    /**
     * Unique identifier of the channel.
     */
    channelId?: string;
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
}
export interface ChannelDeletedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Display name of the channel.
     */
    channelDisplayName?: string;
    /**
     * Unique identifier of the channel.
     */
    channelId?: string;
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
}
export interface ChannelDescriptionUpdatedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * The updated description of the channel.
     */
    channelDescription?: string;
    /**
     * Unique identifier of the channel.
     */
    channelId?: string;
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
}
export interface ChannelIdentity extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The identity of the channel in which the message was posted.
     */
    channelId?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The identity of the team in which the message was posted.
     */
    teamId?: string;
}
export interface ChannelRenamedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * The updated name of the channel.
     */
    channelDisplayName?: string;
    /**
     * Unique identifier of the channel.
     */
    channelId?: string;
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
}
export interface ChannelSetAsFavoriteByDefaultEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Unique identifier of the channel.
     */
    channelId?: string;
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
}
export interface ChannelUnsetAsFavoriteByDefaultEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Unique identifier of the channel.
     */
    channelId?: string;
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
}
export interface ChatMessage extends Entity, Parsable {
    /**
     * References to attached objects like files, tabs, meetings etc.
     */
    attachments?: ChatMessageAttachment[];
    /**
     * The body property
     */
    body?: ItemBody;
    /**
     * If the message was sent in a channel, represents identity of the channel.
     */
    channelIdentity?: ChannelIdentity;
    /**
     * If the message was sent in a chat, represents the identity of the chat.
     */
    chatId?: string;
    /**
     * Timestamp of when the chat message was created.
     */
    createdDateTime?: Date;
    /**
     * Read only. Timestamp at which the chat message was deleted, or null if not deleted.
     */
    deletedDateTime?: Date;
    /**
     * Read-only. Version number of the chat message.
     */
    etag?: string;
    /**
     * Read-only. If present, represents details of an event that happened in a chat, a channel, or a team, for example, adding new members. For event messages, the messageType property will be set to systemEventMessage.
     */
    eventDetail?: EventMessageDetail;
    /**
     * Details of the sender of the chat message. Can only be set during migration.
     */
    from?: ChatMessageFromIdentitySet;
    /**
     * Content in a message hosted by Microsoft Teams - for example, images or code snippets.
     */
    hostedContents?: ChatMessageHostedContent[];
    /**
     * The importance property
     */
    importance?: ChatMessageImportance;
    /**
     * Read only. Timestamp when edits to the chat message were made. Triggers an 'Edited' flag in the Teams UI. If no edits are made the value is null.
     */
    lastEditedDateTime?: Date;
    /**
     * Read only. Timestamp when the chat message is created (initial setting) or modified, including when a reaction is added or removed.
     */
    lastModifiedDateTime?: Date;
    /**
     * Locale of the chat message set by the client. Always set to en-us.
     */
    locale?: string;
    /**
     * List of entities mentioned in the chat message. Supported entities are: user, bot, team, and channel.
     */
    mentions?: ChatMessageMention[];
    /**
     * List of activity history of a message item, including modification time and actions, such as reactionAdded, reactionRemoved, or reaction changes, on the message.
     */
    messageHistory?: ChatMessageHistoryItem[];
    /**
     * The messageType property
     */
    messageType?: ChatMessageType;
    /**
     * Defines the properties of a policy violation set by a data loss prevention (DLP) application.
     */
    policyViolation?: ChatMessagePolicyViolation;
    /**
     * Reactions for this chat message (for example, Like).
     */
    reactions?: ChatMessageReaction[];
    /**
     * Replies for a specified message. Supports $expand for channel messages.
     */
    replies?: ChatMessage[];
    /**
     * Read-only. ID of the parent chat message or root chat message of the thread. (Only applies to chat messages in channels, not chats.)
     */
    replyToId?: string;
    /**
     * The subject of the chat message, in plaintext.
     */
    subject?: string;
    /**
     * Summary text of the chat message that could be used for push notifications and summary views or fall back views. Only applies to channel chat messages, not chat messages in a chat.
     */
    summary?: string;
    /**
     * Read-only. Link to the message in Microsoft Teams.
     */
    webUrl?: string;
}
export type ChatMessageActions = (typeof ChatMessageActionsObject)[keyof typeof ChatMessageActionsObject];
export interface ChatMessageAttachment extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The content of the attachment. If the attachment is a rich card, set the property to the rich card object. This property and contentUrl are mutually exclusive.
     */
    content?: string;
    /**
     * The media type of the content attachment. It can have the following values: reference: Attachment is a link to another file. Populate the contentURL with the link to the object.Any contentType that is supported by the Bot Framework's Attachment objectapplication/vnd.microsoft.card.codesnippet: A code snippet. application/vnd.microsoft.card.announcement: An announcement header.
     */
    contentType?: string;
    /**
     * The URL for the content of the attachment.
     */
    contentUrl?: string;
    /**
     * Read-only. The unique id of the attachment.
     */
    id?: string;
    /**
     * The name of the attachment.
     */
    name?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The ID of the Teams app that is associated with the attachment. The property is used to attribute a Teams message card to the specified app.
     */
    teamsAppId?: string;
    /**
     * The URL to a thumbnail image that the channel can use if it supports using an alternative, smaller form of content or contentUrl. For example, if you set contentType to application/word and set contentUrl to the location of the Word document, you might include a thumbnail image that represents the document. The channel could display the thumbnail image instead of the document. When the user selects the image, the channel would open the document.
     */
    thumbnailUrl?: string;
}
export interface ChatMessageCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: ChatMessage[];
}
export interface ChatMessageFromIdentitySet extends IdentitySet, Parsable {
}
export interface ChatMessageHistoryItem extends AdditionalDataHolder, Parsable {
    /**
     * The actions property
     */
    actions?: ChatMessageActions[];
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The date and time when the message was modified.
     */
    modifiedDateTime?: Date;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The reaction in the modified message.
     */
    reaction?: ChatMessageReaction;
}
export interface ChatMessageHostedContent extends Parsable, TeamworkHostedContent {
}
export type ChatMessageImportance = (typeof ChatMessageImportanceObject)[keyof typeof ChatMessageImportanceObject];
export interface ChatMessageMention extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Index of an entity being mentioned in the specified chatMessage. Matches the {index} value in the corresponding <at id='{index}'> tag in the message body.
     */
    id?: number;
    /**
     * The entity (user, application, team, or channel) that was @mentioned.
     */
    mentioned?: ChatMessageMentionedIdentitySet;
    /**
     * String used to represent the mention. For example, a user's display name, a team name.
     */
    mentionText?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface ChatMessageMentionedIdentitySet extends IdentitySet, Parsable {
    /**
     * If present, represents a conversation (for example, team or channel) @mentioned in a message.
     */
    conversation?: TeamworkConversationIdentity;
}
export interface ChatMessagePolicyViolation extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The action taken by the DLP provider on the message with sensitive content. Supported values are: NoneNotifySender -- Inform the sender of the violation but allow readers to read the message.BlockAccess -- Block readers from reading the message.BlockAccessExternal -- Block users outside the organization from reading the message, while allowing users within the organization to read the message.
     */
    dlpAction?: ChatMessagePolicyViolationDlpActionTypes[];
    /**
     * Justification text provided by the sender of the message when overriding a policy violation.
     */
    justificationText?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Information to display to the message sender about why the message was flagged as a violation.
     */
    policyTip?: ChatMessagePolicyViolationPolicyTip;
    /**
     * Indicates the action taken by the user on a message blocked by the DLP provider. Supported values are: NoneOverrideReportFalsePositiveWhen the DLP provider is updating the message for blocking sensitive content, userAction isn't required.
     */
    userAction?: ChatMessagePolicyViolationUserActionTypes[];
    /**
     * Indicates what actions the sender may take in response to the policy violation. Supported values are: NoneAllowFalsePositiveOverride -- Allows the sender to declare the policyViolation to be an error in the DLP app and its rules, and allow readers to see the message again if the dlpAction hides it.AllowOverrideWithoutJustification -- Allows the sender to override the DLP violation and allow readers to see the message again if the dlpAction hides it, without needing to provide an explanation for doing so. AllowOverrideWithJustification -- Allows the sender to override the DLP violation and allow readers to see the message again if the dlpAction hides it, after providing an explanation for doing so.AllowOverrideWithoutJustification and AllowOverrideWithJustification are mutually exclusive.
     */
    verdictDetails?: ChatMessagePolicyViolationVerdictDetailsTypes[];
}
export type ChatMessagePolicyViolationDlpActionTypes = (typeof ChatMessagePolicyViolationDlpActionTypesObject)[keyof typeof ChatMessagePolicyViolationDlpActionTypesObject];
export interface ChatMessagePolicyViolationPolicyTip extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The URL a user can visit to read about the data loss prevention policies for the organization. (ie, policies about what users shouldn't say in chats)
     */
    complianceUrl?: string;
    /**
     * Explanatory text shown to the sender of the message.
     */
    generalText?: string;
    /**
     * The list of improper data in the message that was detected by the data loss prevention app. Each DLP app defines its own conditions, examples include 'Credit Card Number' and 'Social Security Number'.
     */
    matchedConditionDescriptions?: string[];
    /**
     * The OdataType property
     */
    odataType?: string;
}
export type ChatMessagePolicyViolationUserActionTypes = (typeof ChatMessagePolicyViolationUserActionTypesObject)[keyof typeof ChatMessagePolicyViolationUserActionTypesObject];
export type ChatMessagePolicyViolationVerdictDetailsTypes = (typeof ChatMessagePolicyViolationVerdictDetailsTypesObject)[keyof typeof ChatMessagePolicyViolationVerdictDetailsTypesObject];
export interface ChatMessageReaction extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    createdDateTime?: Date;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Supported values are like, angry, sad, laugh, heart, surprised.
     */
    reactionType?: string;
    /**
     * The user property
     */
    user?: ChatMessageReactionIdentitySet;
}
export interface ChatMessageReactionIdentitySet extends IdentitySet, Parsable {
}
export type ChatMessageType = (typeof ChatMessageTypeObject)[keyof typeof ChatMessageTypeObject];
export interface ChatRenamedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * The updated name of the chat.
     */
    chatDisplayName?: string;
    /**
     * Unique identifier of the chat.
     */
    chatId?: string;
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
}
export interface CommunicationsApplicationIdentity extends Identity, Parsable {
    /**
     * First-party Microsoft application that presents this identity.
     */
    applicationType?: string;
    /**
     * True if the participant shouldn't be shown in other participants' rosters.
     */
    hidden?: boolean;
}
export interface CommunicationsApplicationInstanceIdentity extends Identity, Parsable {
    /**
     * True if the participant shouldn't be shown in other participants' rosters.
     */
    hidden?: boolean;
    /**
     * The tenant ID of the application.
     */
    tenantId?: string;
}
export interface CommunicationsEncryptedIdentity extends Identity, Parsable {
}
export interface CommunicationsGuestIdentity extends Identity, Parsable {
}
export interface CommunicationsIdentitySet extends IdentitySet, Parsable {
    /**
     * The application instance associated with this action.
     */
    applicationInstance?: Identity;
    /**
     * An identity the participant would like to present itself as to the other participants in the call.
     */
    assertedIdentity?: Identity;
    /**
     * The Azure Communication Services user associated with this action.
     */
    azureCommunicationServicesUser?: Identity;
    /**
     * The encrypted user associated with this action.
     */
    encrypted?: Identity;
    /**
     * Type of endpoint that the participant uses. Possible values are: default, voicemail, skypeForBusiness, skypeForBusinessVoipPhone, unknownFutureValue.
     */
    endpointType?: EndpointType;
    /**
     * The guest user associated with this action.
     */
    guest?: Identity;
    /**
     * The Skype for Business on-premises user associated with this action.
     */
    onPremises?: Identity;
    /**
     * The phone user associated with this action.
     */
    phone?: Identity;
}
export interface CommunicationsPhoneIdentity extends Identity, Parsable {
}
export interface CommunicationsUserIdentity extends Identity, Parsable {
    /**
     * The user's tenant ID.
     */
    tenantId?: string;
}
export interface Contact extends OutlookItem, Parsable {
    /**
     * The name of the contact's assistant.
     */
    assistantName?: string;
    /**
     * The contact's birthday. The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    birthday?: Date;
    /**
     * The contact's business address.
     */
    businessAddress?: PhysicalAddress;
    /**
     * The business home page of the contact.
     */
    businessHomePage?: string;
    /**
     * The contact's business phone numbers.
     */
    businessPhones?: string[];
    /**
     * The names of the contact's children.
     */
    children?: string[];
    /**
     * The name of the contact's company.
     */
    companyName?: string;
    /**
     * The contact's department.
     */
    department?: string;
    /**
     * The contact's display name. You can specify the display name in a create or update operation. Note that later updates to other properties may cause an automatically generated value to overwrite the displayName value you have specified. To preserve a pre-existing value, always include it as displayName in an update operation.
     */
    displayName?: string;
    /**
     * The contact's email addresses.
     */
    emailAddresses?: EmailAddress[];
    /**
     * The collection of open extensions defined for the contact. Read-only. Nullable.
     */
    extensions?: Extension[];
    /**
     * The name the contact is filed under.
     */
    fileAs?: string;
    /**
     * The contact's suffix.
     */
    generation?: string;
    /**
     * The contact's given name.
     */
    givenName?: string;
    /**
     * The contact's home address.
     */
    homeAddress?: PhysicalAddress;
    /**
     * The contact's home phone numbers.
     */
    homePhones?: string[];
    /**
     * The contact's instant messaging (IM) addresses.
     */
    imAddresses?: string[];
    /**
     * The contact's initials.
     */
    initials?: string;
    /**
     * The contactâ€™s job title.
     */
    jobTitle?: string;
    /**
     * The name of the contact's manager.
     */
    manager?: string;
    /**
     * The contact's middle name.
     */
    middleName?: string;
    /**
     * The contact's mobile phone number.
     */
    mobilePhone?: string;
    /**
     * The collection of multi-value extended properties defined for the contact. Read-only. Nullable.
     */
    multiValueExtendedProperties?: MultiValueLegacyExtendedProperty[];
    /**
     * The contact's nickname.
     */
    nickName?: string;
    /**
     * The location of the contact's office.
     */
    officeLocation?: string;
    /**
     * Other addresses for the contact.
     */
    otherAddress?: PhysicalAddress;
    /**
     * The ID of the contact's parent folder.
     */
    parentFolderId?: string;
    /**
     * The user's notes about the contact.
     */
    personalNotes?: string;
    /**
     * Optional contact picture. You can get or set a photo for a contact.
     */
    photo?: ProfilePhoto;
    /**
     * The contact's profession.
     */
    profession?: string;
    /**
     * The collection of single-value extended properties defined for the contact. Read-only. Nullable.
     */
    singleValueExtendedProperties?: SingleValueLegacyExtendedProperty[];
    /**
     * The name of the contact's spouse/partner.
     */
    spouseName?: string;
    /**
     * The contact's surname.
     */
    surname?: string;
    /**
     * The contact's title.
     */
    title?: string;
    /**
     * The phonetic Japanese company name of the contact.
     */
    yomiCompanyName?: string;
    /**
     * The phonetic Japanese given name (first name) of the contact.
     */
    yomiGivenName?: string;
    /**
     * The phonetic Japanese surname (last name)  of the contact.
     */
    yomiSurname?: string;
}
export interface ConversationMemberRoleUpdatedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Roles for the coversation member user.
     */
    conversationMemberRoles?: string[];
    /**
     * Identity of the conversation member user.
     */
    conversationMemberUser?: TeamworkUserIdentity;
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Attachment}
 */
export function createAttachmentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.fileAttachment":
                    return deserializeIntoFileAttachment;
                case "#microsoft.graph.itemAttachment":
                    return deserializeIntoItemAttachment;
                case "#microsoft.graph.referenceAttachment":
                    return deserializeIntoReferenceAttachment;
            }
        }
    }
    return deserializeIntoAttachment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AttendeeBase}
 */
export function createAttendeeBaseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.attendee":
                    return deserializeIntoAttendee;
            }
        }
    }
    return deserializeIntoAttendeeBase;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Attendee}
 */
export function createAttendeeFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAttendee;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AzureCommunicationServicesUserIdentity}
 */
export function createAzureCommunicationServicesUserIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAzureCommunicationServicesUserIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BaseCollectionPaginationCountResponse}
 */
export function createBaseCollectionPaginationCountResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBaseCollectionPaginationCountResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BaseDeltaFunctionResponse}
 */
export function createBaseDeltaFunctionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBaseDeltaFunctionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Calendar}
 */
export function createCalendarFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCalendar;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CalendarPermission}
 */
export function createCalendarPermissionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCalendarPermission;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CalendarSharingMessageAction}
 */
export function createCalendarSharingMessageActionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCalendarSharingMessageAction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CalendarSharingMessage}
 */
export function createCalendarSharingMessageFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCalendarSharingMessage;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CallEndedEventMessageDetail}
 */
export function createCallEndedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCallEndedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CallParticipantInfo}
 */
export function createCallParticipantInfoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCallParticipantInfo;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CallRecordingEventMessageDetail}
 */
export function createCallRecordingEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCallRecordingEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CallStartedEventMessageDetail}
 */
export function createCallStartedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCallStartedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CallTranscriptEventMessageDetail}
 */
export function createCallTranscriptEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCallTranscriptEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChannelAddedEventMessageDetail}
 */
export function createChannelAddedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChannelAddedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChannelDeletedEventMessageDetail}
 */
export function createChannelDeletedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChannelDeletedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChannelDescriptionUpdatedEventMessageDetail}
 */
export function createChannelDescriptionUpdatedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChannelDescriptionUpdatedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChannelIdentity}
 */
export function createChannelIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChannelIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChannelRenamedEventMessageDetail}
 */
export function createChannelRenamedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChannelRenamedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChannelSetAsFavoriteByDefaultEventMessageDetail}
 */
export function createChannelSetAsFavoriteByDefaultEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChannelSetAsFavoriteByDefaultEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChannelUnsetAsFavoriteByDefaultEventMessageDetail}
 */
export function createChannelUnsetAsFavoriteByDefaultEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChannelUnsetAsFavoriteByDefaultEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChatMessageAttachment}
 */
export function createChatMessageAttachmentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChatMessageAttachment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChatMessageCollectionResponse}
 */
export function createChatMessageCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChatMessageCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChatMessage}
 */
export function createChatMessageFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChatMessage;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChatMessageFromIdentitySet}
 */
export function createChatMessageFromIdentitySetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChatMessageFromIdentitySet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChatMessageHistoryItem}
 */
export function createChatMessageHistoryItemFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChatMessageHistoryItem;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChatMessageHostedContent}
 */
export function createChatMessageHostedContentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChatMessageHostedContent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChatMessageMentionedIdentitySet}
 */
export function createChatMessageMentionedIdentitySetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChatMessageMentionedIdentitySet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChatMessageMention}
 */
export function createChatMessageMentionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChatMessageMention;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChatMessagePolicyViolation}
 */
export function createChatMessagePolicyViolationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChatMessagePolicyViolation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChatMessagePolicyViolationPolicyTip}
 */
export function createChatMessagePolicyViolationPolicyTipFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChatMessagePolicyViolationPolicyTip;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChatMessageReaction}
 */
export function createChatMessageReactionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChatMessageReaction;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChatMessageReactionIdentitySet}
 */
export function createChatMessageReactionIdentitySetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChatMessageReactionIdentitySet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ChatRenamedEventMessageDetail}
 */
export function createChatRenamedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoChatRenamedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CommunicationsApplicationIdentity}
 */
export function createCommunicationsApplicationIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCommunicationsApplicationIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CommunicationsApplicationInstanceIdentity}
 */
export function createCommunicationsApplicationInstanceIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCommunicationsApplicationInstanceIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CommunicationsEncryptedIdentity}
 */
export function createCommunicationsEncryptedIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCommunicationsEncryptedIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CommunicationsGuestIdentity}
 */
export function createCommunicationsGuestIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCommunicationsGuestIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CommunicationsIdentitySet}
 */
export function createCommunicationsIdentitySetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCommunicationsIdentitySet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CommunicationsPhoneIdentity}
 */
export function createCommunicationsPhoneIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCommunicationsPhoneIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {CommunicationsUserIdentity}
 */
export function createCommunicationsUserIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoCommunicationsUserIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Contact}
 */
export function createContactFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoContact;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ConversationMemberRoleUpdatedEventMessageDetail}
 */
export function createConversationMemberRoleUpdatedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoConversationMemberRoleUpdatedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DateTimeTimeZone}
 */
export function createDateTimeTimeZoneFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDateTimeTimeZone;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DetailsInfo}
 */
export function createDetailsInfoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDetailsInfo;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EmailAddress}
 */
export function createEmailAddressFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEmailAddress;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EmailIdentity}
 */
export function createEmailIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEmailIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Entity}
 */
export function createEntityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.attachment":
                    return deserializeIntoAttachment;
                case "#microsoft.graph.calendar":
                    return deserializeIntoCalendar;
                case "#microsoft.graph.calendarPermission":
                    return deserializeIntoCalendarPermission;
                case "#microsoft.graph.calendarSharingMessage":
                    return deserializeIntoCalendarSharingMessage;
                case "#microsoft.graph.chatMessage":
                    return deserializeIntoChatMessage;
                case "#microsoft.graph.chatMessageHostedContent":
                    return deserializeIntoChatMessageHostedContent;
                case "#microsoft.graph.contact":
                    return deserializeIntoContact;
                case "#microsoft.graph.event":
                    return deserializeIntoEvent;
                case "#microsoft.graph.eventMessage":
                    return deserializeIntoEventMessage;
                case "#microsoft.graph.eventMessageRequest":
                    return deserializeIntoEventMessageRequest;
                case "#microsoft.graph.eventMessageResponse":
                    return deserializeIntoEventMessageResponse;
                case "#microsoft.graph.extension":
                    return deserializeIntoExtension;
                case "#microsoft.graph.fileAttachment":
                    return deserializeIntoFileAttachment;
                case "#microsoft.graph.itemAttachment":
                    return deserializeIntoItemAttachment;
                case "#microsoft.graph.mailFolder":
                    return deserializeIntoMailFolder;
                case "#microsoft.graph.mailSearchFolder":
                    return deserializeIntoMailSearchFolder;
                case "#microsoft.graph.message":
                    return deserializeIntoMessage;
                case "#microsoft.graph.messageRule":
                    return deserializeIntoMessageRule;
                case "#microsoft.graph.multiValueLegacyExtendedProperty":
                    return deserializeIntoMultiValueLegacyExtendedProperty;
                case "#microsoft.graph.openTypeExtension":
                    return deserializeIntoOpenTypeExtension;
                case "#microsoft.graph.outlookItem":
                    return deserializeIntoOutlookItem;
                case "#microsoft.graph.post":
                    return deserializeIntoPost;
                case "#microsoft.graph.profilePhoto":
                    return deserializeIntoProfilePhoto;
                case "#microsoft.graph.referenceAttachment":
                    return deserializeIntoReferenceAttachment;
                case "#microsoft.graph.singleValueLegacyExtendedProperty":
                    return deserializeIntoSingleValueLegacyExtendedProperty;
                case "#microsoft.graph.teamworkHostedContent":
                    return deserializeIntoTeamworkHostedContent;
            }
        }
    }
    return deserializeIntoEntity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Event}
 */
export function createEventFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEvent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EventMessageDetail}
 */
export function createEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.callEndedEventMessageDetail":
                    return deserializeIntoCallEndedEventMessageDetail;
                case "#microsoft.graph.callRecordingEventMessageDetail":
                    return deserializeIntoCallRecordingEventMessageDetail;
                case "#microsoft.graph.callStartedEventMessageDetail":
                    return deserializeIntoCallStartedEventMessageDetail;
                case "#microsoft.graph.callTranscriptEventMessageDetail":
                    return deserializeIntoCallTranscriptEventMessageDetail;
                case "#microsoft.graph.channelAddedEventMessageDetail":
                    return deserializeIntoChannelAddedEventMessageDetail;
                case "#microsoft.graph.channelDeletedEventMessageDetail":
                    return deserializeIntoChannelDeletedEventMessageDetail;
                case "#microsoft.graph.channelDescriptionUpdatedEventMessageDetail":
                    return deserializeIntoChannelDescriptionUpdatedEventMessageDetail;
                case "#microsoft.graph.channelRenamedEventMessageDetail":
                    return deserializeIntoChannelRenamedEventMessageDetail;
                case "#microsoft.graph.channelSetAsFavoriteByDefaultEventMessageDetail":
                    return deserializeIntoChannelSetAsFavoriteByDefaultEventMessageDetail;
                case "#microsoft.graph.channelUnsetAsFavoriteByDefaultEventMessageDetail":
                    return deserializeIntoChannelUnsetAsFavoriteByDefaultEventMessageDetail;
                case "#microsoft.graph.chatRenamedEventMessageDetail":
                    return deserializeIntoChatRenamedEventMessageDetail;
                case "#microsoft.graph.conversationMemberRoleUpdatedEventMessageDetail":
                    return deserializeIntoConversationMemberRoleUpdatedEventMessageDetail;
                case "#microsoft.graph.meetingPolicyUpdatedEventMessageDetail":
                    return deserializeIntoMeetingPolicyUpdatedEventMessageDetail;
                case "#microsoft.graph.membersAddedEventMessageDetail":
                    return deserializeIntoMembersAddedEventMessageDetail;
                case "#microsoft.graph.membersDeletedEventMessageDetail":
                    return deserializeIntoMembersDeletedEventMessageDetail;
                case "#microsoft.graph.membersJoinedEventMessageDetail":
                    return deserializeIntoMembersJoinedEventMessageDetail;
                case "#microsoft.graph.membersLeftEventMessageDetail":
                    return deserializeIntoMembersLeftEventMessageDetail;
                case "#microsoft.graph.messagePinnedEventMessageDetail":
                    return deserializeIntoMessagePinnedEventMessageDetail;
                case "#microsoft.graph.messageUnpinnedEventMessageDetail":
                    return deserializeIntoMessageUnpinnedEventMessageDetail;
                case "#microsoft.graph.tabUpdatedEventMessageDetail":
                    return deserializeIntoTabUpdatedEventMessageDetail;
                case "#microsoft.graph.teamArchivedEventMessageDetail":
                    return deserializeIntoTeamArchivedEventMessageDetail;
                case "#microsoft.graph.teamCreatedEventMessageDetail":
                    return deserializeIntoTeamCreatedEventMessageDetail;
                case "#microsoft.graph.teamDescriptionUpdatedEventMessageDetail":
                    return deserializeIntoTeamDescriptionUpdatedEventMessageDetail;
                case "#microsoft.graph.teamJoiningDisabledEventMessageDetail":
                    return deserializeIntoTeamJoiningDisabledEventMessageDetail;
                case "#microsoft.graph.teamJoiningEnabledEventMessageDetail":
                    return deserializeIntoTeamJoiningEnabledEventMessageDetail;
                case "#microsoft.graph.teamRenamedEventMessageDetail":
                    return deserializeIntoTeamRenamedEventMessageDetail;
                case "#microsoft.graph.teamsAppInstalledEventMessageDetail":
                    return deserializeIntoTeamsAppInstalledEventMessageDetail;
                case "#microsoft.graph.teamsAppRemovedEventMessageDetail":
                    return deserializeIntoTeamsAppRemovedEventMessageDetail;
                case "#microsoft.graph.teamsAppUpgradedEventMessageDetail":
                    return deserializeIntoTeamsAppUpgradedEventMessageDetail;
                case "#microsoft.graph.teamUnarchivedEventMessageDetail":
                    return deserializeIntoTeamUnarchivedEventMessageDetail;
            }
        }
    }
    return deserializeIntoEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EventMessage}
 */
export function createEventMessageFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.eventMessageRequest":
                    return deserializeIntoEventMessageRequest;
                case "#microsoft.graph.eventMessageResponse":
                    return deserializeIntoEventMessageResponse;
            }
        }
    }
    return deserializeIntoEventMessage;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EventMessageRequest}
 */
export function createEventMessageRequestFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEventMessageRequest;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EventMessageResponse}
 */
export function createEventMessageResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEventMessageResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Extension}
 */
export function createExtensionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.openTypeExtension":
                    return deserializeIntoOpenTypeExtension;
            }
        }
    }
    return deserializeIntoExtension;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FileAttachment}
 */
export function createFileAttachmentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFileAttachment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FollowupFlag}
 */
export function createFollowupFlagFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFollowupFlag;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Identity}
 */
export function createIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.azureCommunicationServicesUserIdentity":
                    return deserializeIntoAzureCommunicationServicesUserIdentity;
                case "#microsoft.graph.callRecords.userIdentity":
                    return deserializeIntoUserIdentity;
                case "#microsoft.graph.communicationsApplicationIdentity":
                    return deserializeIntoCommunicationsApplicationIdentity;
                case "#microsoft.graph.communicationsApplicationInstanceIdentity":
                    return deserializeIntoCommunicationsApplicationInstanceIdentity;
                case "#microsoft.graph.communicationsEncryptedIdentity":
                    return deserializeIntoCommunicationsEncryptedIdentity;
                case "#microsoft.graph.communicationsGuestIdentity":
                    return deserializeIntoCommunicationsGuestIdentity;
                case "#microsoft.graph.communicationsPhoneIdentity":
                    return deserializeIntoCommunicationsPhoneIdentity;
                case "#microsoft.graph.communicationsUserIdentity":
                    return deserializeIntoCommunicationsUserIdentity;
                case "#microsoft.graph.emailIdentity":
                    return deserializeIntoEmailIdentity;
                case "#microsoft.graph.initiator":
                    return deserializeIntoInitiator;
                case "#microsoft.graph.provisionedIdentity":
                    return deserializeIntoProvisionedIdentity;
                case "#microsoft.graph.provisioningServicePrincipal":
                    return deserializeIntoProvisioningServicePrincipal;
                case "#microsoft.graph.provisioningSystem":
                    return deserializeIntoProvisioningSystem;
                case "#microsoft.graph.servicePrincipalIdentity":
                    return deserializeIntoServicePrincipalIdentity;
                case "#microsoft.graph.sharePointIdentity":
                    return deserializeIntoSharePointIdentity;
                case "#microsoft.graph.teamworkApplicationIdentity":
                    return deserializeIntoTeamworkApplicationIdentity;
                case "#microsoft.graph.teamworkConversationIdentity":
                    return deserializeIntoTeamworkConversationIdentity;
                case "#microsoft.graph.teamworkTagIdentity":
                    return deserializeIntoTeamworkTagIdentity;
                case "#microsoft.graph.teamworkUserIdentity":
                    return deserializeIntoTeamworkUserIdentity;
                case "#microsoft.graph.userIdentity":
                    return deserializeIntoUserIdentity;
            }
        }
    }
    return deserializeIntoIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IdentitySet}
 */
export function createIdentitySetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.chatMessageFromIdentitySet":
                    return deserializeIntoChatMessageFromIdentitySet;
                case "#microsoft.graph.chatMessageMentionedIdentitySet":
                    return deserializeIntoChatMessageMentionedIdentitySet;
                case "#microsoft.graph.chatMessageReactionIdentitySet":
                    return deserializeIntoChatMessageReactionIdentitySet;
                case "#microsoft.graph.communicationsIdentitySet":
                    return deserializeIntoCommunicationsIdentitySet;
                case "#microsoft.graph.sharePointIdentitySet":
                    return deserializeIntoSharePointIdentitySet;
            }
        }
    }
    return deserializeIntoIdentitySet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Initiator}
 */
export function createInitiatorFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoInitiator;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {InternetMessageHeader}
 */
export function createInternetMessageHeaderFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoInternetMessageHeader;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ItemAttachment}
 */
export function createItemAttachmentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoItemAttachment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ItemBody}
 */
export function createItemBodyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoItemBody;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {LocationConstraintItem}
 */
export function createLocationConstraintItemFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoLocationConstraintItem;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Location}
 */
export function createLocationFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.locationConstraintItem":
                    return deserializeIntoLocationConstraintItem;
            }
        }
    }
    return deserializeIntoLocation;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MailFolderCollectionResponse}
 */
export function createMailFolderCollectionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMailFolderCollectionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MailFolder}
 */
export function createMailFolderFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.mailSearchFolder":
                    return deserializeIntoMailSearchFolder;
            }
        }
    }
    return deserializeIntoMailFolder;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MailSearchFolder}
 */
export function createMailSearchFolderFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMailSearchFolder;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MeetingPolicyUpdatedEventMessageDetail}
 */
export function createMeetingPolicyUpdatedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMeetingPolicyUpdatedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MembersAddedEventMessageDetail}
 */
export function createMembersAddedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMembersAddedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MembersDeletedEventMessageDetail}
 */
export function createMembersDeletedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMembersDeletedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MembersJoinedEventMessageDetail}
 */
export function createMembersJoinedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMembersJoinedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MembersLeftEventMessageDetail}
 */
export function createMembersLeftEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMembersLeftEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Message}
 */
export function createMessageFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.calendarSharingMessage":
                    return deserializeIntoCalendarSharingMessage;
                case "#microsoft.graph.eventMessage":
                    return deserializeIntoEventMessage;
                case "#microsoft.graph.eventMessageRequest":
                    return deserializeIntoEventMessageRequest;
                case "#microsoft.graph.eventMessageResponse":
                    return deserializeIntoEventMessageResponse;
            }
        }
    }
    return deserializeIntoMessage;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MessagePinnedEventMessageDetail}
 */
export function createMessagePinnedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMessagePinnedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MessageRuleActions}
 */
export function createMessageRuleActionsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMessageRuleActions;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MessageRule}
 */
export function createMessageRuleFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMessageRule;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MessageRulePredicates}
 */
export function createMessageRulePredicatesFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMessageRulePredicates;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MessageUnpinnedEventMessageDetail}
 */
export function createMessageUnpinnedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMessageUnpinnedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MultiValueLegacyExtendedProperty}
 */
export function createMultiValueLegacyExtendedPropertyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMultiValueLegacyExtendedProperty;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {OnlineMeetingInfo}
 */
export function createOnlineMeetingInfoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoOnlineMeetingInfo;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {OpenTypeExtension}
 */
export function createOpenTypeExtensionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoOpenTypeExtension;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {OutlookGeoCoordinates}
 */
export function createOutlookGeoCoordinatesFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoOutlookGeoCoordinates;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {OutlookItem}
 */
export function createOutlookItemFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.calendarSharingMessage":
                    return deserializeIntoCalendarSharingMessage;
                case "#microsoft.graph.contact":
                    return deserializeIntoContact;
                case "#microsoft.graph.event":
                    return deserializeIntoEvent;
                case "#microsoft.graph.eventMessage":
                    return deserializeIntoEventMessage;
                case "#microsoft.graph.eventMessageRequest":
                    return deserializeIntoEventMessageRequest;
                case "#microsoft.graph.eventMessageResponse":
                    return deserializeIntoEventMessageResponse;
                case "#microsoft.graph.message":
                    return deserializeIntoMessage;
                case "#microsoft.graph.post":
                    return deserializeIntoPost;
            }
        }
    }
    return deserializeIntoOutlookItem;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PatternedRecurrence}
 */
export function createPatternedRecurrenceFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPatternedRecurrence;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Phone}
 */
export function createPhoneFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPhone;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PhysicalAddress}
 */
export function createPhysicalAddressFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPhysicalAddress;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Post}
 */
export function createPostFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPost;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ProfilePhoto}
 */
export function createProfilePhotoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProfilePhoto;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ProvisionedIdentity}
 */
export function createProvisionedIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProvisionedIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ProvisioningServicePrincipal}
 */
export function createProvisioningServicePrincipalFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProvisioningServicePrincipal;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ProvisioningSystem}
 */
export function createProvisioningSystemFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoProvisioningSystem;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Recipient}
 */
export function createRecipientFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.attendee":
                    return deserializeIntoAttendee;
                case "#microsoft.graph.attendeeBase":
                    return deserializeIntoAttendeeBase;
            }
        }
    }
    return deserializeIntoRecipient;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RecurrencePattern}
 */
export function createRecurrencePatternFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRecurrencePattern;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RecurrenceRange}
 */
export function createRecurrenceRangeFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRecurrenceRange;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ReferenceAttachment}
 */
export function createReferenceAttachmentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoReferenceAttachment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ResponseStatus}
 */
export function createResponseStatusFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoResponseStatus;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ServicePrincipalIdentity}
 */
export function createServicePrincipalIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoServicePrincipalIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SharePointIdentity}
 */
export function createSharePointIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSharePointIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SharePointIdentitySet}
 */
export function createSharePointIdentitySetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSharePointIdentitySet;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SingleValueLegacyExtendedProperty}
 */
export function createSingleValueLegacyExtendedPropertyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSingleValueLegacyExtendedProperty;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SizeRange}
 */
export function createSizeRangeFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSizeRange;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TabUpdatedEventMessageDetail}
 */
export function createTabUpdatedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTabUpdatedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TeamArchivedEventMessageDetail}
 */
export function createTeamArchivedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTeamArchivedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TeamCreatedEventMessageDetail}
 */
export function createTeamCreatedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTeamCreatedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TeamDescriptionUpdatedEventMessageDetail}
 */
export function createTeamDescriptionUpdatedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTeamDescriptionUpdatedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TeamJoiningDisabledEventMessageDetail}
 */
export function createTeamJoiningDisabledEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTeamJoiningDisabledEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TeamJoiningEnabledEventMessageDetail}
 */
export function createTeamJoiningEnabledEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTeamJoiningEnabledEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TeamRenamedEventMessageDetail}
 */
export function createTeamRenamedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTeamRenamedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TeamsAppInstalledEventMessageDetail}
 */
export function createTeamsAppInstalledEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTeamsAppInstalledEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TeamsAppRemovedEventMessageDetail}
 */
export function createTeamsAppRemovedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTeamsAppRemovedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TeamsAppUpgradedEventMessageDetail}
 */
export function createTeamsAppUpgradedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTeamsAppUpgradedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TeamUnarchivedEventMessageDetail}
 */
export function createTeamUnarchivedEventMessageDetailFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTeamUnarchivedEventMessageDetail;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TeamworkApplicationIdentity}
 */
export function createTeamworkApplicationIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTeamworkApplicationIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TeamworkConversationIdentity}
 */
export function createTeamworkConversationIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTeamworkConversationIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TeamworkHostedContent}
 */
export function createTeamworkHostedContentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    if(!parseNode) throw new Error("parseNode cannot be undefined");
    const mappingValueNode = parseNode.getChildNode("@odata.type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "#microsoft.graph.chatMessageHostedContent":
                    return deserializeIntoChatMessageHostedContent;
            }
        }
    }
    return deserializeIntoTeamworkHostedContent;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TeamworkTagIdentity}
 */
export function createTeamworkTagIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTeamworkTagIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TeamworkUserIdentity}
 */
export function createTeamworkUserIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTeamworkUserIdentity;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TimeSlot}
 */
export function createTimeSlotFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTimeSlot;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {UserIdentity}
 */
export function createUserIdentityFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoUserIdentity;
}
export interface DateTimeTimeZone extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * A single point of time in a combined date and time representation ({date}T{time}; for example, 2017-08-29T04:00:00.0000000).
     */
    dateTime?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Represents a time zone, for example, 'Pacific Standard Time'. See below for more possible values.
     */
    timeZone?: string;
}
export type DayOfWeek = (typeof DayOfWeekObject)[keyof typeof DayOfWeekObject];
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAttachment(attachment: Partial<Attachment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(attachment),
        "contentType": n => { attachment.contentType = n.getStringValue(); },
        "isInline": n => { attachment.isInline = n.getBooleanValue(); },
        "lastModifiedDateTime": n => { attachment.lastModifiedDateTime = n.getDateValue(); },
        "name": n => { attachment.name = n.getStringValue(); },
        "size": n => { attachment.size = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAttendee(attendee: Partial<Attendee> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAttendeeBase(attendee),
        "proposedNewTime": n => { attendee.proposedNewTime = n.getObjectValue<TimeSlot>(createTimeSlotFromDiscriminatorValue); },
        "status": n => { attendee.status = n.getObjectValue<ResponseStatus>(createResponseStatusFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAttendeeBase(attendeeBase: Partial<AttendeeBase> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoRecipient(attendeeBase),
        "type": n => { attendeeBase.type = n.getEnumValue<AttendeeType>(AttendeeTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoAzureCommunicationServicesUserIdentity(azureCommunicationServicesUserIdentity: Partial<AzureCommunicationServicesUserIdentity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(azureCommunicationServicesUserIdentity),
        "azureCommunicationServicesResourceId": n => { azureCommunicationServicesUserIdentity.azureCommunicationServicesResourceId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoBaseCollectionPaginationCountResponse(baseCollectionPaginationCountResponse: Partial<BaseCollectionPaginationCountResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.count": n => { baseCollectionPaginationCountResponse.odataCount = n.getNumberValue(); },
        "@odata.nextLink": n => { baseCollectionPaginationCountResponse.odataNextLink = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoBaseDeltaFunctionResponse(baseDeltaFunctionResponse: Partial<BaseDeltaFunctionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.deltaLink": n => { baseDeltaFunctionResponse.odataDeltaLink = n.getStringValue(); },
        "@odata.nextLink": n => { baseDeltaFunctionResponse.odataNextLink = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCalendar(calendar: Partial<Calendar> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(calendar),
        "allowedOnlineMeetingProviders": n => { calendar.allowedOnlineMeetingProviders = n.getCollectionOfEnumValues<OnlineMeetingProviderType>(OnlineMeetingProviderTypeObject); },
        "calendarPermissions": n => { calendar.calendarPermissions = n.getCollectionOfObjectValues<CalendarPermission>(createCalendarPermissionFromDiscriminatorValue); },
        "calendarView": n => { calendar.calendarView = n.getCollectionOfObjectValues<Event>(createEventFromDiscriminatorValue); },
        "canEdit": n => { calendar.canEdit = n.getBooleanValue(); },
        "canShare": n => { calendar.canShare = n.getBooleanValue(); },
        "canViewPrivateItems": n => { calendar.canViewPrivateItems = n.getBooleanValue(); },
        "changeKey": n => { calendar.changeKey = n.getStringValue(); },
        "color": n => { calendar.color = n.getEnumValue<CalendarColor>(CalendarColorObject); },
        "defaultOnlineMeetingProvider": n => { calendar.defaultOnlineMeetingProvider = n.getEnumValue<OnlineMeetingProviderType>(OnlineMeetingProviderTypeObject); },
        "events": n => { calendar.events = n.getCollectionOfObjectValues<Event>(createEventFromDiscriminatorValue); },
        "hexColor": n => { calendar.hexColor = n.getStringValue(); },
        "isDefaultCalendar": n => { calendar.isDefaultCalendar = n.getBooleanValue(); },
        "isRemovable": n => { calendar.isRemovable = n.getBooleanValue(); },
        "isTallyingResponses": n => { calendar.isTallyingResponses = n.getBooleanValue(); },
        "multiValueExtendedProperties": n => { calendar.multiValueExtendedProperties = n.getCollectionOfObjectValues<MultiValueLegacyExtendedProperty>(createMultiValueLegacyExtendedPropertyFromDiscriminatorValue); },
        "name": n => { calendar.name = n.getStringValue(); },
        "owner": n => { calendar.owner = n.getObjectValue<EmailAddress>(createEmailAddressFromDiscriminatorValue); },
        "singleValueExtendedProperties": n => { calendar.singleValueExtendedProperties = n.getCollectionOfObjectValues<SingleValueLegacyExtendedProperty>(createSingleValueLegacyExtendedPropertyFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCalendarPermission(calendarPermission: Partial<CalendarPermission> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(calendarPermission),
        "allowedRoles": n => { calendarPermission.allowedRoles = n.getCollectionOfEnumValues<CalendarRoleType>(CalendarRoleTypeObject); },
        "emailAddress": n => { calendarPermission.emailAddress = n.getObjectValue<EmailAddress>(createEmailAddressFromDiscriminatorValue); },
        "isInsideOrganization": n => { calendarPermission.isInsideOrganization = n.getBooleanValue(); },
        "isRemovable": n => { calendarPermission.isRemovable = n.getBooleanValue(); },
        "role": n => { calendarPermission.role = n.getEnumValue<CalendarRoleType>(CalendarRoleTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCalendarSharingMessage(calendarSharingMessage: Partial<CalendarSharingMessage> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoMessage(calendarSharingMessage),
        "canAccept": n => { calendarSharingMessage.canAccept = n.getBooleanValue(); },
        "sharingMessageAction": n => { calendarSharingMessage.sharingMessageAction = n.getObjectValue<CalendarSharingMessageAction>(createCalendarSharingMessageActionFromDiscriminatorValue); },
        "sharingMessageActions": n => { calendarSharingMessage.sharingMessageActions = n.getCollectionOfObjectValues<CalendarSharingMessageAction>(createCalendarSharingMessageActionFromDiscriminatorValue); },
        "suggestedCalendarName": n => { calendarSharingMessage.suggestedCalendarName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCalendarSharingMessageAction(calendarSharingMessageAction: Partial<CalendarSharingMessageAction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "action": n => { calendarSharingMessageAction.action = n.getEnumValue<CalendarSharingAction>(CalendarSharingActionObject); },
        "actionType": n => { calendarSharingMessageAction.actionType = n.getEnumValue<CalendarSharingActionType>(CalendarSharingActionTypeObject); },
        "importance": n => { calendarSharingMessageAction.importance = n.getEnumValue<CalendarSharingActionImportance>(CalendarSharingActionImportanceObject); },
        "@odata.type": n => { calendarSharingMessageAction.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCallEndedEventMessageDetail(callEndedEventMessageDetail: Partial<CallEndedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(callEndedEventMessageDetail),
        "callDuration": n => { callEndedEventMessageDetail.callDuration = n.getDurationValue(); },
        "callEventType": n => { callEndedEventMessageDetail.callEventType = n.getEnumValue<TeamworkCallEventType>(TeamworkCallEventTypeObject); },
        "callId": n => { callEndedEventMessageDetail.callId = n.getStringValue(); },
        "callParticipants": n => { callEndedEventMessageDetail.callParticipants = n.getCollectionOfObjectValues<CallParticipantInfo>(createCallParticipantInfoFromDiscriminatorValue); },
        "initiator": n => { callEndedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCallParticipantInfo(callParticipantInfo: Partial<CallParticipantInfo> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.type": n => { callParticipantInfo.odataType = n.getStringValue(); },
        "participant": n => { callParticipantInfo.participant = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCallRecordingEventMessageDetail(callRecordingEventMessageDetail: Partial<CallRecordingEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(callRecordingEventMessageDetail),
        "callId": n => { callRecordingEventMessageDetail.callId = n.getStringValue(); },
        "callRecordingDisplayName": n => { callRecordingEventMessageDetail.callRecordingDisplayName = n.getStringValue(); },
        "callRecordingDuration": n => { callRecordingEventMessageDetail.callRecordingDuration = n.getDurationValue(); },
        "callRecordingStatus": n => { callRecordingEventMessageDetail.callRecordingStatus = n.getEnumValue<CallRecordingStatus>(CallRecordingStatusObject); },
        "callRecordingUrl": n => { callRecordingEventMessageDetail.callRecordingUrl = n.getStringValue(); },
        "initiator": n => { callRecordingEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "meetingOrganizer": n => { callRecordingEventMessageDetail.meetingOrganizer = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCallStartedEventMessageDetail(callStartedEventMessageDetail: Partial<CallStartedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(callStartedEventMessageDetail),
        "callEventType": n => { callStartedEventMessageDetail.callEventType = n.getEnumValue<TeamworkCallEventType>(TeamworkCallEventTypeObject); },
        "callId": n => { callStartedEventMessageDetail.callId = n.getStringValue(); },
        "initiator": n => { callStartedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCallTranscriptEventMessageDetail(callTranscriptEventMessageDetail: Partial<CallTranscriptEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(callTranscriptEventMessageDetail),
        "callId": n => { callTranscriptEventMessageDetail.callId = n.getStringValue(); },
        "callTranscriptICalUid": n => { callTranscriptEventMessageDetail.callTranscriptICalUid = n.getStringValue(); },
        "meetingOrganizer": n => { callTranscriptEventMessageDetail.meetingOrganizer = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChannelAddedEventMessageDetail(channelAddedEventMessageDetail: Partial<ChannelAddedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(channelAddedEventMessageDetail),
        "channelDisplayName": n => { channelAddedEventMessageDetail.channelDisplayName = n.getStringValue(); },
        "channelId": n => { channelAddedEventMessageDetail.channelId = n.getStringValue(); },
        "initiator": n => { channelAddedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChannelDeletedEventMessageDetail(channelDeletedEventMessageDetail: Partial<ChannelDeletedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(channelDeletedEventMessageDetail),
        "channelDisplayName": n => { channelDeletedEventMessageDetail.channelDisplayName = n.getStringValue(); },
        "channelId": n => { channelDeletedEventMessageDetail.channelId = n.getStringValue(); },
        "initiator": n => { channelDeletedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChannelDescriptionUpdatedEventMessageDetail(channelDescriptionUpdatedEventMessageDetail: Partial<ChannelDescriptionUpdatedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(channelDescriptionUpdatedEventMessageDetail),
        "channelDescription": n => { channelDescriptionUpdatedEventMessageDetail.channelDescription = n.getStringValue(); },
        "channelId": n => { channelDescriptionUpdatedEventMessageDetail.channelId = n.getStringValue(); },
        "initiator": n => { channelDescriptionUpdatedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChannelIdentity(channelIdentity: Partial<ChannelIdentity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "channelId": n => { channelIdentity.channelId = n.getStringValue(); },
        "@odata.type": n => { channelIdentity.odataType = n.getStringValue(); },
        "teamId": n => { channelIdentity.teamId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChannelRenamedEventMessageDetail(channelRenamedEventMessageDetail: Partial<ChannelRenamedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(channelRenamedEventMessageDetail),
        "channelDisplayName": n => { channelRenamedEventMessageDetail.channelDisplayName = n.getStringValue(); },
        "channelId": n => { channelRenamedEventMessageDetail.channelId = n.getStringValue(); },
        "initiator": n => { channelRenamedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChannelSetAsFavoriteByDefaultEventMessageDetail(channelSetAsFavoriteByDefaultEventMessageDetail: Partial<ChannelSetAsFavoriteByDefaultEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(channelSetAsFavoriteByDefaultEventMessageDetail),
        "channelId": n => { channelSetAsFavoriteByDefaultEventMessageDetail.channelId = n.getStringValue(); },
        "initiator": n => { channelSetAsFavoriteByDefaultEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChannelUnsetAsFavoriteByDefaultEventMessageDetail(channelUnsetAsFavoriteByDefaultEventMessageDetail: Partial<ChannelUnsetAsFavoriteByDefaultEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(channelUnsetAsFavoriteByDefaultEventMessageDetail),
        "channelId": n => { channelUnsetAsFavoriteByDefaultEventMessageDetail.channelId = n.getStringValue(); },
        "initiator": n => { channelUnsetAsFavoriteByDefaultEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChatMessage(chatMessage: Partial<ChatMessage> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(chatMessage),
        "attachments": n => { chatMessage.attachments = n.getCollectionOfObjectValues<ChatMessageAttachment>(createChatMessageAttachmentFromDiscriminatorValue); },
        "body": n => { chatMessage.body = n.getObjectValue<ItemBody>(createItemBodyFromDiscriminatorValue); },
        "channelIdentity": n => { chatMessage.channelIdentity = n.getObjectValue<ChannelIdentity>(createChannelIdentityFromDiscriminatorValue); },
        "chatId": n => { chatMessage.chatId = n.getStringValue(); },
        "createdDateTime": n => { chatMessage.createdDateTime = n.getDateValue(); },
        "deletedDateTime": n => { chatMessage.deletedDateTime = n.getDateValue(); },
        "etag": n => { chatMessage.etag = n.getStringValue(); },
        "eventDetail": n => { chatMessage.eventDetail = n.getObjectValue<EventMessageDetail>(createEventMessageDetailFromDiscriminatorValue); },
        "from": n => { chatMessage.from = n.getObjectValue<ChatMessageFromIdentitySet>(createChatMessageFromIdentitySetFromDiscriminatorValue); },
        "hostedContents": n => { chatMessage.hostedContents = n.getCollectionOfObjectValues<ChatMessageHostedContent>(createChatMessageHostedContentFromDiscriminatorValue); },
        "importance": n => { chatMessage.importance = n.getEnumValue<ChatMessageImportance>(ChatMessageImportanceObject); },
        "lastEditedDateTime": n => { chatMessage.lastEditedDateTime = n.getDateValue(); },
        "lastModifiedDateTime": n => { chatMessage.lastModifiedDateTime = n.getDateValue(); },
        "locale": n => { chatMessage.locale = n.getStringValue(); },
        "mentions": n => { chatMessage.mentions = n.getCollectionOfObjectValues<ChatMessageMention>(createChatMessageMentionFromDiscriminatorValue); },
        "messageHistory": n => { chatMessage.messageHistory = n.getCollectionOfObjectValues<ChatMessageHistoryItem>(createChatMessageHistoryItemFromDiscriminatorValue); },
        "messageType": n => { chatMessage.messageType = n.getEnumValue<ChatMessageType>(ChatMessageTypeObject); },
        "policyViolation": n => { chatMessage.policyViolation = n.getObjectValue<ChatMessagePolicyViolation>(createChatMessagePolicyViolationFromDiscriminatorValue); },
        "reactions": n => { chatMessage.reactions = n.getCollectionOfObjectValues<ChatMessageReaction>(createChatMessageReactionFromDiscriminatorValue); },
        "replies": n => { chatMessage.replies = n.getCollectionOfObjectValues<ChatMessage>(createChatMessageFromDiscriminatorValue); },
        "replyToId": n => { chatMessage.replyToId = n.getStringValue(); },
        "subject": n => { chatMessage.subject = n.getStringValue(); },
        "summary": n => { chatMessage.summary = n.getStringValue(); },
        "webUrl": n => { chatMessage.webUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChatMessageAttachment(chatMessageAttachment: Partial<ChatMessageAttachment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "content": n => { chatMessageAttachment.content = n.getStringValue(); },
        "contentType": n => { chatMessageAttachment.contentType = n.getStringValue(); },
        "contentUrl": n => { chatMessageAttachment.contentUrl = n.getStringValue(); },
        "id": n => { chatMessageAttachment.id = n.getStringValue(); },
        "name": n => { chatMessageAttachment.name = n.getStringValue(); },
        "@odata.type": n => { chatMessageAttachment.odataType = n.getStringValue(); },
        "teamsAppId": n => { chatMessageAttachment.teamsAppId = n.getStringValue(); },
        "thumbnailUrl": n => { chatMessageAttachment.thumbnailUrl = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChatMessageCollectionResponse(chatMessageCollectionResponse: Partial<ChatMessageCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(chatMessageCollectionResponse),
        "value": n => { chatMessageCollectionResponse.value = n.getCollectionOfObjectValues<ChatMessage>(createChatMessageFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChatMessageFromIdentitySet(chatMessageFromIdentitySet: Partial<ChatMessageFromIdentitySet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentitySet(chatMessageFromIdentitySet),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChatMessageHistoryItem(chatMessageHistoryItem: Partial<ChatMessageHistoryItem> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "actions": n => { chatMessageHistoryItem.actions = n.getCollectionOfEnumValues<ChatMessageActions>(ChatMessageActionsObject); },
        "modifiedDateTime": n => { chatMessageHistoryItem.modifiedDateTime = n.getDateValue(); },
        "@odata.type": n => { chatMessageHistoryItem.odataType = n.getStringValue(); },
        "reaction": n => { chatMessageHistoryItem.reaction = n.getObjectValue<ChatMessageReaction>(createChatMessageReactionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChatMessageHostedContent(chatMessageHostedContent: Partial<ChatMessageHostedContent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoTeamworkHostedContent(chatMessageHostedContent),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChatMessageMention(chatMessageMention: Partial<ChatMessageMention> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "id": n => { chatMessageMention.id = n.getNumberValue(); },
        "mentioned": n => { chatMessageMention.mentioned = n.getObjectValue<ChatMessageMentionedIdentitySet>(createChatMessageMentionedIdentitySetFromDiscriminatorValue); },
        "mentionText": n => { chatMessageMention.mentionText = n.getStringValue(); },
        "@odata.type": n => { chatMessageMention.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChatMessageMentionedIdentitySet(chatMessageMentionedIdentitySet: Partial<ChatMessageMentionedIdentitySet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentitySet(chatMessageMentionedIdentitySet),
        "conversation": n => { chatMessageMentionedIdentitySet.conversation = n.getObjectValue<TeamworkConversationIdentity>(createTeamworkConversationIdentityFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChatMessagePolicyViolation(chatMessagePolicyViolation: Partial<ChatMessagePolicyViolation> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "dlpAction": n => { chatMessagePolicyViolation.dlpAction = n.getCollectionOfEnumValues<ChatMessagePolicyViolationDlpActionTypes>(ChatMessagePolicyViolationDlpActionTypesObject); },
        "justificationText": n => { chatMessagePolicyViolation.justificationText = n.getStringValue(); },
        "@odata.type": n => { chatMessagePolicyViolation.odataType = n.getStringValue(); },
        "policyTip": n => { chatMessagePolicyViolation.policyTip = n.getObjectValue<ChatMessagePolicyViolationPolicyTip>(createChatMessagePolicyViolationPolicyTipFromDiscriminatorValue); },
        "userAction": n => { chatMessagePolicyViolation.userAction = n.getCollectionOfEnumValues<ChatMessagePolicyViolationUserActionTypes>(ChatMessagePolicyViolationUserActionTypesObject); },
        "verdictDetails": n => { chatMessagePolicyViolation.verdictDetails = n.getCollectionOfEnumValues<ChatMessagePolicyViolationVerdictDetailsTypes>(ChatMessagePolicyViolationVerdictDetailsTypesObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChatMessagePolicyViolationPolicyTip(chatMessagePolicyViolationPolicyTip: Partial<ChatMessagePolicyViolationPolicyTip> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "complianceUrl": n => { chatMessagePolicyViolationPolicyTip.complianceUrl = n.getStringValue(); },
        "generalText": n => { chatMessagePolicyViolationPolicyTip.generalText = n.getStringValue(); },
        "matchedConditionDescriptions": n => { chatMessagePolicyViolationPolicyTip.matchedConditionDescriptions = n.getCollectionOfPrimitiveValues<string>(); },
        "@odata.type": n => { chatMessagePolicyViolationPolicyTip.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChatMessageReaction(chatMessageReaction: Partial<ChatMessageReaction> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "createdDateTime": n => { chatMessageReaction.createdDateTime = n.getDateValue(); },
        "@odata.type": n => { chatMessageReaction.odataType = n.getStringValue(); },
        "reactionType": n => { chatMessageReaction.reactionType = n.getStringValue(); },
        "user": n => { chatMessageReaction.user = n.getObjectValue<ChatMessageReactionIdentitySet>(createChatMessageReactionIdentitySetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChatMessageReactionIdentitySet(chatMessageReactionIdentitySet: Partial<ChatMessageReactionIdentitySet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentitySet(chatMessageReactionIdentitySet),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoChatRenamedEventMessageDetail(chatRenamedEventMessageDetail: Partial<ChatRenamedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(chatRenamedEventMessageDetail),
        "chatDisplayName": n => { chatRenamedEventMessageDetail.chatDisplayName = n.getStringValue(); },
        "chatId": n => { chatRenamedEventMessageDetail.chatId = n.getStringValue(); },
        "initiator": n => { chatRenamedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCommunicationsApplicationIdentity(communicationsApplicationIdentity: Partial<CommunicationsApplicationIdentity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(communicationsApplicationIdentity),
        "applicationType": n => { communicationsApplicationIdentity.applicationType = n.getStringValue(); },
        "hidden": n => { communicationsApplicationIdentity.hidden = n.getBooleanValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCommunicationsApplicationInstanceIdentity(communicationsApplicationInstanceIdentity: Partial<CommunicationsApplicationInstanceIdentity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(communicationsApplicationInstanceIdentity),
        "hidden": n => { communicationsApplicationInstanceIdentity.hidden = n.getBooleanValue(); },
        "tenantId": n => { communicationsApplicationInstanceIdentity.tenantId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCommunicationsEncryptedIdentity(communicationsEncryptedIdentity: Partial<CommunicationsEncryptedIdentity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(communicationsEncryptedIdentity),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCommunicationsGuestIdentity(communicationsGuestIdentity: Partial<CommunicationsGuestIdentity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(communicationsGuestIdentity),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCommunicationsIdentitySet(communicationsIdentitySet: Partial<CommunicationsIdentitySet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentitySet(communicationsIdentitySet),
        "applicationInstance": n => { communicationsIdentitySet.applicationInstance = n.getObjectValue<Identity>(createIdentityFromDiscriminatorValue); },
        "assertedIdentity": n => { communicationsIdentitySet.assertedIdentity = n.getObjectValue<Identity>(createIdentityFromDiscriminatorValue); },
        "azureCommunicationServicesUser": n => { communicationsIdentitySet.azureCommunicationServicesUser = n.getObjectValue<Identity>(createIdentityFromDiscriminatorValue); },
        "encrypted": n => { communicationsIdentitySet.encrypted = n.getObjectValue<Identity>(createIdentityFromDiscriminatorValue); },
        "endpointType": n => { communicationsIdentitySet.endpointType = n.getEnumValue<EndpointType>(EndpointTypeObject); },
        "guest": n => { communicationsIdentitySet.guest = n.getObjectValue<Identity>(createIdentityFromDiscriminatorValue); },
        "onPremises": n => { communicationsIdentitySet.onPremises = n.getObjectValue<Identity>(createIdentityFromDiscriminatorValue); },
        "phone": n => { communicationsIdentitySet.phone = n.getObjectValue<Identity>(createIdentityFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCommunicationsPhoneIdentity(communicationsPhoneIdentity: Partial<CommunicationsPhoneIdentity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(communicationsPhoneIdentity),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoCommunicationsUserIdentity(communicationsUserIdentity: Partial<CommunicationsUserIdentity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(communicationsUserIdentity),
        "tenantId": n => { communicationsUserIdentity.tenantId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoContact(contact: Partial<Contact> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoOutlookItem(contact),
        "assistantName": n => { contact.assistantName = n.getStringValue(); },
        "birthday": n => { contact.birthday = n.getDateValue(); },
        "businessAddress": n => { contact.businessAddress = n.getObjectValue<PhysicalAddress>(createPhysicalAddressFromDiscriminatorValue); },
        "businessHomePage": n => { contact.businessHomePage = n.getStringValue(); },
        "businessPhones": n => { contact.businessPhones = n.getCollectionOfPrimitiveValues<string>(); },
        "children": n => { contact.children = n.getCollectionOfPrimitiveValues<string>(); },
        "companyName": n => { contact.companyName = n.getStringValue(); },
        "department": n => { contact.department = n.getStringValue(); },
        "displayName": n => { contact.displayName = n.getStringValue(); },
        "emailAddresses": n => { contact.emailAddresses = n.getCollectionOfObjectValues<EmailAddress>(createEmailAddressFromDiscriminatorValue); },
        "extensions": n => { contact.extensions = n.getCollectionOfObjectValues<Extension>(createExtensionFromDiscriminatorValue); },
        "fileAs": n => { contact.fileAs = n.getStringValue(); },
        "generation": n => { contact.generation = n.getStringValue(); },
        "givenName": n => { contact.givenName = n.getStringValue(); },
        "homeAddress": n => { contact.homeAddress = n.getObjectValue<PhysicalAddress>(createPhysicalAddressFromDiscriminatorValue); },
        "homePhones": n => { contact.homePhones = n.getCollectionOfPrimitiveValues<string>(); },
        "imAddresses": n => { contact.imAddresses = n.getCollectionOfPrimitiveValues<string>(); },
        "initials": n => { contact.initials = n.getStringValue(); },
        "jobTitle": n => { contact.jobTitle = n.getStringValue(); },
        "manager": n => { contact.manager = n.getStringValue(); },
        "middleName": n => { contact.middleName = n.getStringValue(); },
        "mobilePhone": n => { contact.mobilePhone = n.getStringValue(); },
        "multiValueExtendedProperties": n => { contact.multiValueExtendedProperties = n.getCollectionOfObjectValues<MultiValueLegacyExtendedProperty>(createMultiValueLegacyExtendedPropertyFromDiscriminatorValue); },
        "nickName": n => { contact.nickName = n.getStringValue(); },
        "officeLocation": n => { contact.officeLocation = n.getStringValue(); },
        "otherAddress": n => { contact.otherAddress = n.getObjectValue<PhysicalAddress>(createPhysicalAddressFromDiscriminatorValue); },
        "parentFolderId": n => { contact.parentFolderId = n.getStringValue(); },
        "personalNotes": n => { contact.personalNotes = n.getStringValue(); },
        "photo": n => { contact.photo = n.getObjectValue<ProfilePhoto>(createProfilePhotoFromDiscriminatorValue); },
        "profession": n => { contact.profession = n.getStringValue(); },
        "singleValueExtendedProperties": n => { contact.singleValueExtendedProperties = n.getCollectionOfObjectValues<SingleValueLegacyExtendedProperty>(createSingleValueLegacyExtendedPropertyFromDiscriminatorValue); },
        "spouseName": n => { contact.spouseName = n.getStringValue(); },
        "surname": n => { contact.surname = n.getStringValue(); },
        "title": n => { contact.title = n.getStringValue(); },
        "yomiCompanyName": n => { contact.yomiCompanyName = n.getStringValue(); },
        "yomiGivenName": n => { contact.yomiGivenName = n.getStringValue(); },
        "yomiSurname": n => { contact.yomiSurname = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoConversationMemberRoleUpdatedEventMessageDetail(conversationMemberRoleUpdatedEventMessageDetail: Partial<ConversationMemberRoleUpdatedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(conversationMemberRoleUpdatedEventMessageDetail),
        "conversationMemberRoles": n => { conversationMemberRoleUpdatedEventMessageDetail.conversationMemberRoles = n.getCollectionOfPrimitiveValues<string>(); },
        "conversationMemberUser": n => { conversationMemberRoleUpdatedEventMessageDetail.conversationMemberUser = n.getObjectValue<TeamworkUserIdentity>(createTeamworkUserIdentityFromDiscriminatorValue); },
        "initiator": n => { conversationMemberRoleUpdatedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDateTimeTimeZone(dateTimeTimeZone: Partial<DateTimeTimeZone> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "dateTime": n => { dateTimeTimeZone.dateTime = n.getStringValue(); },
        "@odata.type": n => { dateTimeTimeZone.odataType = n.getStringValue(); },
        "timeZone": n => { dateTimeTimeZone.timeZone = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoDetailsInfo(detailsInfo: Partial<DetailsInfo> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.type": n => { detailsInfo.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEmailAddress(emailAddress: Partial<EmailAddress> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "address": n => { emailAddress.address = n.getStringValue(); },
        "name": n => { emailAddress.name = n.getStringValue(); },
        "@odata.type": n => { emailAddress.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEmailIdentity(emailIdentity: Partial<EmailIdentity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(emailIdentity),
        "email": n => { emailIdentity.email = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEntity(entity: Partial<Entity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "id": n => { entity.id = n.getStringValue(); },
        "@odata.type": n => { entity.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEvent(event: Partial<Event> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoOutlookItem(event),
        "allowNewTimeProposals": n => { event.allowNewTimeProposals = n.getBooleanValue(); },
        "attachments": n => { event.attachments = n.getCollectionOfObjectValues<Attachment>(createAttachmentFromDiscriminatorValue); },
        "attendees": n => { event.attendees = n.getCollectionOfObjectValues<Attendee>(createAttendeeFromDiscriminatorValue); },
        "body": n => { event.body = n.getObjectValue<ItemBody>(createItemBodyFromDiscriminatorValue); },
        "bodyPreview": n => { event.bodyPreview = n.getStringValue(); },
        "calendar": n => { event.calendar = n.getObjectValue<Calendar>(createCalendarFromDiscriminatorValue); },
        "end": n => { event.end = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "extensions": n => { event.extensions = n.getCollectionOfObjectValues<Extension>(createExtensionFromDiscriminatorValue); },
        "hasAttachments": n => { event.hasAttachments = n.getBooleanValue(); },
        "hideAttendees": n => { event.hideAttendees = n.getBooleanValue(); },
        "iCalUId": n => { event.iCalUId = n.getStringValue(); },
        "importance": n => { event.importance = n.getEnumValue<Importance>(ImportanceObject); },
        "instances": n => { event.instances = n.getCollectionOfObjectValues<Event>(createEventFromDiscriminatorValue); },
        "isAllDay": n => { event.isAllDay = n.getBooleanValue(); },
        "isCancelled": n => { event.isCancelled = n.getBooleanValue(); },
        "isDraft": n => { event.isDraft = n.getBooleanValue(); },
        "isOnlineMeeting": n => { event.isOnlineMeeting = n.getBooleanValue(); },
        "isOrganizer": n => { event.isOrganizer = n.getBooleanValue(); },
        "isReminderOn": n => { event.isReminderOn = n.getBooleanValue(); },
        "location": n => { event.location = n.getObjectValue<Location>(createLocationFromDiscriminatorValue); },
        "locations": n => { event.locations = n.getCollectionOfObjectValues<Location>(createLocationFromDiscriminatorValue); },
        "multiValueExtendedProperties": n => { event.multiValueExtendedProperties = n.getCollectionOfObjectValues<MultiValueLegacyExtendedProperty>(createMultiValueLegacyExtendedPropertyFromDiscriminatorValue); },
        "onlineMeeting": n => { event.onlineMeeting = n.getObjectValue<OnlineMeetingInfo>(createOnlineMeetingInfoFromDiscriminatorValue); },
        "onlineMeetingProvider": n => { event.onlineMeetingProvider = n.getEnumValue<OnlineMeetingProviderType>(OnlineMeetingProviderTypeObject); },
        "onlineMeetingUrl": n => { event.onlineMeetingUrl = n.getStringValue(); },
        "organizer": n => { event.organizer = n.getObjectValue<Recipient>(createRecipientFromDiscriminatorValue); },
        "originalEndTimeZone": n => { event.originalEndTimeZone = n.getStringValue(); },
        "originalStart": n => { event.originalStart = n.getDateValue(); },
        "originalStartTimeZone": n => { event.originalStartTimeZone = n.getStringValue(); },
        "recurrence": n => { event.recurrence = n.getObjectValue<PatternedRecurrence>(createPatternedRecurrenceFromDiscriminatorValue); },
        "reminderMinutesBeforeStart": n => { event.reminderMinutesBeforeStart = n.getNumberValue(); },
        "responseRequested": n => { event.responseRequested = n.getBooleanValue(); },
        "responseStatus": n => { event.responseStatus = n.getObjectValue<ResponseStatus>(createResponseStatusFromDiscriminatorValue); },
        "sensitivity": n => { event.sensitivity = n.getEnumValue<Sensitivity>(SensitivityObject); },
        "seriesMasterId": n => { event.seriesMasterId = n.getStringValue(); },
        "showAs": n => { event.showAs = n.getEnumValue<FreeBusyStatus>(FreeBusyStatusObject); },
        "singleValueExtendedProperties": n => { event.singleValueExtendedProperties = n.getCollectionOfObjectValues<SingleValueLegacyExtendedProperty>(createSingleValueLegacyExtendedPropertyFromDiscriminatorValue); },
        "start": n => { event.start = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "subject": n => { event.subject = n.getStringValue(); },
        "transactionId": n => { event.transactionId = n.getStringValue(); },
        "type": n => { event.type = n.getEnumValue<EventType>(EventTypeObject); },
        "webLink": n => { event.webLink = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEventMessage(eventMessage: Partial<EventMessage> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoMessage(eventMessage),
        "endDateTime": n => { eventMessage.endDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "event": n => { eventMessage.event = n.getObjectValue<Event>(createEventFromDiscriminatorValue); },
        "isAllDay": n => { eventMessage.isAllDay = n.getBooleanValue(); },
        "isDelegated": n => { eventMessage.isDelegated = n.getBooleanValue(); },
        "isOutOfDate": n => { eventMessage.isOutOfDate = n.getBooleanValue(); },
        "location": n => { eventMessage.location = n.getObjectValue<Location>(createLocationFromDiscriminatorValue); },
        "meetingMessageType": n => { eventMessage.meetingMessageType = n.getEnumValue<MeetingMessageType>(MeetingMessageTypeObject); },
        "recurrence": n => { eventMessage.recurrence = n.getObjectValue<PatternedRecurrence>(createPatternedRecurrenceFromDiscriminatorValue); },
        "startDateTime": n => { eventMessage.startDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "type": n => { eventMessage.type = n.getEnumValue<EventType>(EventTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEventMessageDetail(eventMessageDetail: Partial<EventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.type": n => { eventMessageDetail.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEventMessageRequest(eventMessageRequest: Partial<EventMessageRequest> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessage(eventMessageRequest),
        "allowNewTimeProposals": n => { eventMessageRequest.allowNewTimeProposals = n.getBooleanValue(); },
        "meetingRequestType": n => { eventMessageRequest.meetingRequestType = n.getEnumValue<MeetingRequestType>(MeetingRequestTypeObject); },
        "previousEndDateTime": n => { eventMessageRequest.previousEndDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "previousLocation": n => { eventMessageRequest.previousLocation = n.getObjectValue<Location>(createLocationFromDiscriminatorValue); },
        "previousStartDateTime": n => { eventMessageRequest.previousStartDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "responseRequested": n => { eventMessageRequest.responseRequested = n.getBooleanValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoEventMessageResponse(eventMessageResponse: Partial<EventMessageResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessage(eventMessageResponse),
        "proposedNewTime": n => { eventMessageResponse.proposedNewTime = n.getObjectValue<TimeSlot>(createTimeSlotFromDiscriminatorValue); },
        "responseType": n => { eventMessageResponse.responseType = n.getEnumValue<ResponseType>(ResponseTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoExtension(extension: Partial<Extension> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(extension),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFileAttachment(fileAttachment: Partial<FileAttachment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAttachment(fileAttachment),
        "contentBytes": n => { fileAttachment.contentBytes = n.getStringValue(); },
        "contentId": n => { fileAttachment.contentId = n.getStringValue(); },
        "contentLocation": n => { fileAttachment.contentLocation = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoFollowupFlag(followupFlag: Partial<FollowupFlag> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "completedDateTime": n => { followupFlag.completedDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "dueDateTime": n => { followupFlag.dueDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "flagStatus": n => { followupFlag.flagStatus = n.getEnumValue<FollowupFlagStatus>(FollowupFlagStatusObject); },
        "@odata.type": n => { followupFlag.odataType = n.getStringValue(); },
        "startDateTime": n => { followupFlag.startDateTime = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIdentity(identity: Partial<Identity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "displayName": n => { identity.displayName = n.getStringValue(); },
        "id": n => { identity.id = n.getStringValue(); },
        "@odata.type": n => { identity.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoIdentitySet(identitySet: Partial<IdentitySet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "application": n => { identitySet.application = n.getObjectValue<Identity>(createIdentityFromDiscriminatorValue); },
        "device": n => { identitySet.device = n.getObjectValue<Identity>(createIdentityFromDiscriminatorValue); },
        "@odata.type": n => { identitySet.odataType = n.getStringValue(); },
        "user": n => { identitySet.user = n.getObjectValue<Identity>(createIdentityFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoInitiator(initiator: Partial<Initiator> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(initiator),
        "initiatorType": n => { initiator.initiatorType = n.getEnumValue<InitiatorType>(InitiatorTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoInternetMessageHeader(internetMessageHeader: Partial<InternetMessageHeader> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "name": n => { internetMessageHeader.name = n.getStringValue(); },
        "@odata.type": n => { internetMessageHeader.odataType = n.getStringValue(); },
        "value": n => { internetMessageHeader.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoItemAttachment(itemAttachment: Partial<ItemAttachment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAttachment(itemAttachment),
        "item": n => { itemAttachment.item = n.getObjectValue<OutlookItem>(createOutlookItemFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoItemBody(itemBody: Partial<ItemBody> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "content": n => { itemBody.content = n.getStringValue(); },
        "contentType": n => { itemBody.contentType = n.getEnumValue<BodyType>(BodyTypeObject); },
        "@odata.type": n => { itemBody.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoLocation(location: Partial<Location> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "address": n => { location.address = n.getObjectValue<PhysicalAddress>(createPhysicalAddressFromDiscriminatorValue); },
        "coordinates": n => { location.coordinates = n.getObjectValue<OutlookGeoCoordinates>(createOutlookGeoCoordinatesFromDiscriminatorValue); },
        "displayName": n => { location.displayName = n.getStringValue(); },
        "locationEmailAddress": n => { location.locationEmailAddress = n.getStringValue(); },
        "locationType": n => { location.locationType = n.getEnumValue<LocationType>(LocationTypeObject); },
        "locationUri": n => { location.locationUri = n.getStringValue(); },
        "@odata.type": n => { location.odataType = n.getStringValue(); },
        "uniqueId": n => { location.uniqueId = n.getStringValue(); },
        "uniqueIdType": n => { location.uniqueIdType = n.getEnumValue<LocationUniqueIdType>(LocationUniqueIdTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoLocationConstraintItem(locationConstraintItem: Partial<LocationConstraintItem> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoLocation(locationConstraintItem),
        "resolveAvailability": n => { locationConstraintItem.resolveAvailability = n.getBooleanValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMailFolder(mailFolder: Partial<MailFolder> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(mailFolder),
        "childFolderCount": n => { mailFolder.childFolderCount = n.getNumberValue(); },
        "childFolders": n => { mailFolder.childFolders = n.getCollectionOfObjectValues<MailFolder>(createMailFolderFromDiscriminatorValue); },
        "displayName": n => { mailFolder.displayName = n.getStringValue(); },
        "isHidden": n => { mailFolder.isHidden = n.getBooleanValue(); },
        "messageRules": n => { mailFolder.messageRules = n.getCollectionOfObjectValues<MessageRule>(createMessageRuleFromDiscriminatorValue); },
        "messages": n => { mailFolder.messages = n.getCollectionOfObjectValues<Message>(createMessageFromDiscriminatorValue); },
        "multiValueExtendedProperties": n => { mailFolder.multiValueExtendedProperties = n.getCollectionOfObjectValues<MultiValueLegacyExtendedProperty>(createMultiValueLegacyExtendedPropertyFromDiscriminatorValue); },
        "parentFolderId": n => { mailFolder.parentFolderId = n.getStringValue(); },
        "singleValueExtendedProperties": n => { mailFolder.singleValueExtendedProperties = n.getCollectionOfObjectValues<SingleValueLegacyExtendedProperty>(createSingleValueLegacyExtendedPropertyFromDiscriminatorValue); },
        "totalItemCount": n => { mailFolder.totalItemCount = n.getNumberValue(); },
        "unreadItemCount": n => { mailFolder.unreadItemCount = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMailFolderCollectionResponse(mailFolderCollectionResponse: Partial<MailFolderCollectionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseCollectionPaginationCountResponse(mailFolderCollectionResponse),
        "value": n => { mailFolderCollectionResponse.value = n.getCollectionOfObjectValues<MailFolder>(createMailFolderFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMailSearchFolder(mailSearchFolder: Partial<MailSearchFolder> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoMailFolder(mailSearchFolder),
        "filterQuery": n => { mailSearchFolder.filterQuery = n.getStringValue(); },
        "includeNestedFolders": n => { mailSearchFolder.includeNestedFolders = n.getBooleanValue(); },
        "isSupported": n => { mailSearchFolder.isSupported = n.getBooleanValue(); },
        "sourceFolderIds": n => { mailSearchFolder.sourceFolderIds = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMeetingPolicyUpdatedEventMessageDetail(meetingPolicyUpdatedEventMessageDetail: Partial<MeetingPolicyUpdatedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(meetingPolicyUpdatedEventMessageDetail),
        "initiator": n => { meetingPolicyUpdatedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "meetingChatEnabled": n => { meetingPolicyUpdatedEventMessageDetail.meetingChatEnabled = n.getBooleanValue(); },
        "meetingChatId": n => { meetingPolicyUpdatedEventMessageDetail.meetingChatId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMembersAddedEventMessageDetail(membersAddedEventMessageDetail: Partial<MembersAddedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(membersAddedEventMessageDetail),
        "initiator": n => { membersAddedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "members": n => { membersAddedEventMessageDetail.members = n.getCollectionOfObjectValues<TeamworkUserIdentity>(createTeamworkUserIdentityFromDiscriminatorValue); },
        "visibleHistoryStartDateTime": n => { membersAddedEventMessageDetail.visibleHistoryStartDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMembersDeletedEventMessageDetail(membersDeletedEventMessageDetail: Partial<MembersDeletedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(membersDeletedEventMessageDetail),
        "initiator": n => { membersDeletedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "members": n => { membersDeletedEventMessageDetail.members = n.getCollectionOfObjectValues<TeamworkUserIdentity>(createTeamworkUserIdentityFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMembersJoinedEventMessageDetail(membersJoinedEventMessageDetail: Partial<MembersJoinedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(membersJoinedEventMessageDetail),
        "initiator": n => { membersJoinedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "members": n => { membersJoinedEventMessageDetail.members = n.getCollectionOfObjectValues<TeamworkUserIdentity>(createTeamworkUserIdentityFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMembersLeftEventMessageDetail(membersLeftEventMessageDetail: Partial<MembersLeftEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(membersLeftEventMessageDetail),
        "initiator": n => { membersLeftEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "members": n => { membersLeftEventMessageDetail.members = n.getCollectionOfObjectValues<TeamworkUserIdentity>(createTeamworkUserIdentityFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMessage(message: Partial<Message> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoOutlookItem(message),
        "attachments": n => { message.attachments = n.getCollectionOfObjectValues<Attachment>(createAttachmentFromDiscriminatorValue); },
        "bccRecipients": n => { message.bccRecipients = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "body": n => { message.body = n.getObjectValue<ItemBody>(createItemBodyFromDiscriminatorValue); },
        "bodyPreview": n => { message.bodyPreview = n.getStringValue(); },
        "ccRecipients": n => { message.ccRecipients = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "conversationId": n => { message.conversationId = n.getStringValue(); },
        "conversationIndex": n => { message.conversationIndex = n.getStringValue(); },
        "extensions": n => { message.extensions = n.getCollectionOfObjectValues<Extension>(createExtensionFromDiscriminatorValue); },
        "flag": n => { message.flag = n.getObjectValue<FollowupFlag>(createFollowupFlagFromDiscriminatorValue); },
        "from": n => { message.from = n.getObjectValue<Recipient>(createRecipientFromDiscriminatorValue); },
        "hasAttachments": n => { message.hasAttachments = n.getBooleanValue(); },
        "importance": n => { message.importance = n.getEnumValue<Importance>(ImportanceObject); },
        "inferenceClassification": n => { message.inferenceClassification = n.getEnumValue<InferenceClassificationType>(InferenceClassificationTypeObject); },
        "internetMessageHeaders": n => { message.internetMessageHeaders = n.getCollectionOfObjectValues<InternetMessageHeader>(createInternetMessageHeaderFromDiscriminatorValue); },
        "internetMessageId": n => { message.internetMessageId = n.getStringValue(); },
        "isDeliveryReceiptRequested": n => { message.isDeliveryReceiptRequested = n.getBooleanValue(); },
        "isDraft": n => { message.isDraft = n.getBooleanValue(); },
        "isRead": n => { message.isRead = n.getBooleanValue(); },
        "isReadReceiptRequested": n => { message.isReadReceiptRequested = n.getBooleanValue(); },
        "multiValueExtendedProperties": n => { message.multiValueExtendedProperties = n.getCollectionOfObjectValues<MultiValueLegacyExtendedProperty>(createMultiValueLegacyExtendedPropertyFromDiscriminatorValue); },
        "parentFolderId": n => { message.parentFolderId = n.getStringValue(); },
        "receivedDateTime": n => { message.receivedDateTime = n.getDateValue(); },
        "replyTo": n => { message.replyTo = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "sender": n => { message.sender = n.getObjectValue<Recipient>(createRecipientFromDiscriminatorValue); },
        "sentDateTime": n => { message.sentDateTime = n.getDateValue(); },
        "singleValueExtendedProperties": n => { message.singleValueExtendedProperties = n.getCollectionOfObjectValues<SingleValueLegacyExtendedProperty>(createSingleValueLegacyExtendedPropertyFromDiscriminatorValue); },
        "subject": n => { message.subject = n.getStringValue(); },
        "toRecipients": n => { message.toRecipients = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "uniqueBody": n => { message.uniqueBody = n.getObjectValue<ItemBody>(createItemBodyFromDiscriminatorValue); },
        "webLink": n => { message.webLink = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMessagePinnedEventMessageDetail(messagePinnedEventMessageDetail: Partial<MessagePinnedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(messagePinnedEventMessageDetail),
        "eventDateTime": n => { messagePinnedEventMessageDetail.eventDateTime = n.getDateValue(); },
        "initiator": n => { messagePinnedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMessageRule(messageRule: Partial<MessageRule> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(messageRule),
        "actions": n => { messageRule.actions = n.getObjectValue<MessageRuleActions>(createMessageRuleActionsFromDiscriminatorValue); },
        "conditions": n => { messageRule.conditions = n.getObjectValue<MessageRulePredicates>(createMessageRulePredicatesFromDiscriminatorValue); },
        "displayName": n => { messageRule.displayName = n.getStringValue(); },
        "exceptions": n => { messageRule.exceptions = n.getObjectValue<MessageRulePredicates>(createMessageRulePredicatesFromDiscriminatorValue); },
        "hasError": n => { messageRule.hasError = n.getBooleanValue(); },
        "isEnabled": n => { messageRule.isEnabled = n.getBooleanValue(); },
        "isReadOnly": n => { messageRule.isReadOnly = n.getBooleanValue(); },
        "sequence": n => { messageRule.sequence = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMessageRuleActions(messageRuleActions: Partial<MessageRuleActions> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "assignCategories": n => { messageRuleActions.assignCategories = n.getCollectionOfPrimitiveValues<string>(); },
        "copyToFolder": n => { messageRuleActions.copyToFolder = n.getStringValue(); },
        "delete": n => { messageRuleActions.delete = n.getBooleanValue(); },
        "forwardAsAttachmentTo": n => { messageRuleActions.forwardAsAttachmentTo = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "forwardTo": n => { messageRuleActions.forwardTo = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "markAsRead": n => { messageRuleActions.markAsRead = n.getBooleanValue(); },
        "markImportance": n => { messageRuleActions.markImportance = n.getEnumValue<Importance>(ImportanceObject); },
        "moveToFolder": n => { messageRuleActions.moveToFolder = n.getStringValue(); },
        "@odata.type": n => { messageRuleActions.odataType = n.getStringValue(); },
        "permanentDelete": n => { messageRuleActions.permanentDelete = n.getBooleanValue(); },
        "redirectTo": n => { messageRuleActions.redirectTo = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "stopProcessingRules": n => { messageRuleActions.stopProcessingRules = n.getBooleanValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMessageRulePredicates(messageRulePredicates: Partial<MessageRulePredicates> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "bodyContains": n => { messageRulePredicates.bodyContains = n.getCollectionOfPrimitiveValues<string>(); },
        "bodyOrSubjectContains": n => { messageRulePredicates.bodyOrSubjectContains = n.getCollectionOfPrimitiveValues<string>(); },
        "categories": n => { messageRulePredicates.categories = n.getCollectionOfPrimitiveValues<string>(); },
        "fromAddresses": n => { messageRulePredicates.fromAddresses = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "hasAttachments": n => { messageRulePredicates.hasAttachments = n.getBooleanValue(); },
        "headerContains": n => { messageRulePredicates.headerContains = n.getCollectionOfPrimitiveValues<string>(); },
        "importance": n => { messageRulePredicates.importance = n.getEnumValue<Importance>(ImportanceObject); },
        "isApprovalRequest": n => { messageRulePredicates.isApprovalRequest = n.getBooleanValue(); },
        "isAutomaticForward": n => { messageRulePredicates.isAutomaticForward = n.getBooleanValue(); },
        "isAutomaticReply": n => { messageRulePredicates.isAutomaticReply = n.getBooleanValue(); },
        "isEncrypted": n => { messageRulePredicates.isEncrypted = n.getBooleanValue(); },
        "isMeetingRequest": n => { messageRulePredicates.isMeetingRequest = n.getBooleanValue(); },
        "isMeetingResponse": n => { messageRulePredicates.isMeetingResponse = n.getBooleanValue(); },
        "isNonDeliveryReport": n => { messageRulePredicates.isNonDeliveryReport = n.getBooleanValue(); },
        "isPermissionControlled": n => { messageRulePredicates.isPermissionControlled = n.getBooleanValue(); },
        "isReadReceipt": n => { messageRulePredicates.isReadReceipt = n.getBooleanValue(); },
        "isSigned": n => { messageRulePredicates.isSigned = n.getBooleanValue(); },
        "isVoicemail": n => { messageRulePredicates.isVoicemail = n.getBooleanValue(); },
        "messageActionFlag": n => { messageRulePredicates.messageActionFlag = n.getEnumValue<MessageActionFlag>(MessageActionFlagObject); },
        "notSentToMe": n => { messageRulePredicates.notSentToMe = n.getBooleanValue(); },
        "@odata.type": n => { messageRulePredicates.odataType = n.getStringValue(); },
        "recipientContains": n => { messageRulePredicates.recipientContains = n.getCollectionOfPrimitiveValues<string>(); },
        "senderContains": n => { messageRulePredicates.senderContains = n.getCollectionOfPrimitiveValues<string>(); },
        "sensitivity": n => { messageRulePredicates.sensitivity = n.getEnumValue<Sensitivity>(SensitivityObject); },
        "sentCcMe": n => { messageRulePredicates.sentCcMe = n.getBooleanValue(); },
        "sentOnlyToMe": n => { messageRulePredicates.sentOnlyToMe = n.getBooleanValue(); },
        "sentToAddresses": n => { messageRulePredicates.sentToAddresses = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "sentToMe": n => { messageRulePredicates.sentToMe = n.getBooleanValue(); },
        "sentToOrCcMe": n => { messageRulePredicates.sentToOrCcMe = n.getBooleanValue(); },
        "subjectContains": n => { messageRulePredicates.subjectContains = n.getCollectionOfPrimitiveValues<string>(); },
        "withinSizeRange": n => { messageRulePredicates.withinSizeRange = n.getObjectValue<SizeRange>(createSizeRangeFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMessageUnpinnedEventMessageDetail(messageUnpinnedEventMessageDetail: Partial<MessageUnpinnedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(messageUnpinnedEventMessageDetail),
        "eventDateTime": n => { messageUnpinnedEventMessageDetail.eventDateTime = n.getDateValue(); },
        "initiator": n => { messageUnpinnedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoMultiValueLegacyExtendedProperty(multiValueLegacyExtendedProperty: Partial<MultiValueLegacyExtendedProperty> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(multiValueLegacyExtendedProperty),
        "value": n => { multiValueLegacyExtendedProperty.value = n.getCollectionOfPrimitiveValues<string>(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoOnlineMeetingInfo(onlineMeetingInfo: Partial<OnlineMeetingInfo> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "conferenceId": n => { onlineMeetingInfo.conferenceId = n.getStringValue(); },
        "joinUrl": n => { onlineMeetingInfo.joinUrl = n.getStringValue(); },
        "@odata.type": n => { onlineMeetingInfo.odataType = n.getStringValue(); },
        "phones": n => { onlineMeetingInfo.phones = n.getCollectionOfObjectValues<Phone>(createPhoneFromDiscriminatorValue); },
        "quickDial": n => { onlineMeetingInfo.quickDial = n.getStringValue(); },
        "tollFreeNumbers": n => { onlineMeetingInfo.tollFreeNumbers = n.getCollectionOfPrimitiveValues<string>(); },
        "tollNumber": n => { onlineMeetingInfo.tollNumber = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoOpenTypeExtension(openTypeExtension: Partial<OpenTypeExtension> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoExtension(openTypeExtension),
        "extensionName": n => { openTypeExtension.extensionName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoOutlookGeoCoordinates(outlookGeoCoordinates: Partial<OutlookGeoCoordinates> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "accuracy": n => { outlookGeoCoordinates.accuracy = n.getNumberValue(); },
        "altitude": n => { outlookGeoCoordinates.altitude = n.getNumberValue(); },
        "altitudeAccuracy": n => { outlookGeoCoordinates.altitudeAccuracy = n.getNumberValue(); },
        "latitude": n => { outlookGeoCoordinates.latitude = n.getNumberValue(); },
        "longitude": n => { outlookGeoCoordinates.longitude = n.getNumberValue(); },
        "@odata.type": n => { outlookGeoCoordinates.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoOutlookItem(outlookItem: Partial<OutlookItem> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(outlookItem),
        "categories": n => { outlookItem.categories = n.getCollectionOfPrimitiveValues<string>(); },
        "changeKey": n => { outlookItem.changeKey = n.getStringValue(); },
        "createdDateTime": n => { outlookItem.createdDateTime = n.getDateValue(); },
        "lastModifiedDateTime": n => { outlookItem.lastModifiedDateTime = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoPatternedRecurrence(patternedRecurrence: Partial<PatternedRecurrence> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.type": n => { patternedRecurrence.odataType = n.getStringValue(); },
        "pattern": n => { patternedRecurrence.pattern = n.getObjectValue<RecurrencePattern>(createRecurrencePatternFromDiscriminatorValue); },
        "range": n => { patternedRecurrence.range = n.getObjectValue<RecurrenceRange>(createRecurrenceRangeFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoPhone(phone: Partial<Phone> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "language": n => { phone.language = n.getStringValue(); },
        "number": n => { phone.number = n.getStringValue(); },
        "@odata.type": n => { phone.odataType = n.getStringValue(); },
        "region": n => { phone.region = n.getStringValue(); },
        "type": n => { phone.type = n.getEnumValue<PhoneType>(PhoneTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoPhysicalAddress(physicalAddress: Partial<PhysicalAddress> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "city": n => { physicalAddress.city = n.getStringValue(); },
        "countryOrRegion": n => { physicalAddress.countryOrRegion = n.getStringValue(); },
        "@odata.type": n => { physicalAddress.odataType = n.getStringValue(); },
        "postalCode": n => { physicalAddress.postalCode = n.getStringValue(); },
        "state": n => { physicalAddress.state = n.getStringValue(); },
        "street": n => { physicalAddress.street = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoPost(post: Partial<Post> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoOutlookItem(post),
        "attachments": n => { post.attachments = n.getCollectionOfObjectValues<Attachment>(createAttachmentFromDiscriminatorValue); },
        "body": n => { post.body = n.getObjectValue<ItemBody>(createItemBodyFromDiscriminatorValue); },
        "conversationId": n => { post.conversationId = n.getStringValue(); },
        "conversationThreadId": n => { post.conversationThreadId = n.getStringValue(); },
        "extensions": n => { post.extensions = n.getCollectionOfObjectValues<Extension>(createExtensionFromDiscriminatorValue); },
        "from": n => { post.from = n.getObjectValue<Recipient>(createRecipientFromDiscriminatorValue); },
        "hasAttachments": n => { post.hasAttachments = n.getBooleanValue(); },
        "inReplyTo": n => { post.inReplyTo = n.getObjectValue<Post>(createPostFromDiscriminatorValue); },
        "multiValueExtendedProperties": n => { post.multiValueExtendedProperties = n.getCollectionOfObjectValues<MultiValueLegacyExtendedProperty>(createMultiValueLegacyExtendedPropertyFromDiscriminatorValue); },
        "newParticipants": n => { post.newParticipants = n.getCollectionOfObjectValues<Recipient>(createRecipientFromDiscriminatorValue); },
        "receivedDateTime": n => { post.receivedDateTime = n.getDateValue(); },
        "sender": n => { post.sender = n.getObjectValue<Recipient>(createRecipientFromDiscriminatorValue); },
        "singleValueExtendedProperties": n => { post.singleValueExtendedProperties = n.getCollectionOfObjectValues<SingleValueLegacyExtendedProperty>(createSingleValueLegacyExtendedPropertyFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoProfilePhoto(profilePhoto: Partial<ProfilePhoto> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(profilePhoto),
        "height": n => { profilePhoto.height = n.getNumberValue(); },
        "width": n => { profilePhoto.width = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoProvisionedIdentity(provisionedIdentity: Partial<ProvisionedIdentity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(provisionedIdentity),
        "details": n => { provisionedIdentity.details = n.getObjectValue<DetailsInfo>(createDetailsInfoFromDiscriminatorValue); },
        "identityType": n => { provisionedIdentity.identityType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoProvisioningServicePrincipal(provisioningServicePrincipal: Partial<ProvisioningServicePrincipal> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(provisioningServicePrincipal),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoProvisioningSystem(provisioningSystem: Partial<ProvisioningSystem> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(provisioningSystem),
        "details": n => { provisioningSystem.details = n.getObjectValue<DetailsInfo>(createDetailsInfoFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRecipient(recipient: Partial<Recipient> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "emailAddress": n => { recipient.emailAddress = n.getObjectValue<EmailAddress>(createEmailAddressFromDiscriminatorValue); },
        "@odata.type": n => { recipient.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRecurrencePattern(recurrencePattern: Partial<RecurrencePattern> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "dayOfMonth": n => { recurrencePattern.dayOfMonth = n.getNumberValue(); },
        "daysOfWeek": n => { recurrencePattern.daysOfWeek = n.getCollectionOfEnumValues<DayOfWeek>(DayOfWeekObject); },
        "firstDayOfWeek": n => { recurrencePattern.firstDayOfWeek = n.getEnumValue<DayOfWeek>(DayOfWeekObject); },
        "index": n => { recurrencePattern.index = n.getEnumValue<WeekIndex>(WeekIndexObject); },
        "interval": n => { recurrencePattern.interval = n.getNumberValue(); },
        "month": n => { recurrencePattern.month = n.getNumberValue(); },
        "@odata.type": n => { recurrencePattern.odataType = n.getStringValue(); },
        "type": n => { recurrencePattern.type = n.getEnumValue<RecurrencePatternType>(RecurrencePatternTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoRecurrenceRange(recurrenceRange: Partial<RecurrenceRange> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "endDate": n => { recurrenceRange.endDate = n.getDateOnlyValue(); },
        "numberOfOccurrences": n => { recurrenceRange.numberOfOccurrences = n.getNumberValue(); },
        "@odata.type": n => { recurrenceRange.odataType = n.getStringValue(); },
        "recurrenceTimeZone": n => { recurrenceRange.recurrenceTimeZone = n.getStringValue(); },
        "startDate": n => { recurrenceRange.startDate = n.getDateOnlyValue(); },
        "type": n => { recurrenceRange.type = n.getEnumValue<RecurrenceRangeType>(RecurrenceRangeTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoReferenceAttachment(referenceAttachment: Partial<ReferenceAttachment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoAttachment(referenceAttachment),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoResponseStatus(responseStatus: Partial<ResponseStatus> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "@odata.type": n => { responseStatus.odataType = n.getStringValue(); },
        "response": n => { responseStatus.response = n.getEnumValue<ResponseType>(ResponseTypeObject); },
        "time": n => { responseStatus.time = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoServicePrincipalIdentity(servicePrincipalIdentity: Partial<ServicePrincipalIdentity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(servicePrincipalIdentity),
        "appId": n => { servicePrincipalIdentity.appId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSharePointIdentity(sharePointIdentity: Partial<SharePointIdentity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(sharePointIdentity),
        "loginName": n => { sharePointIdentity.loginName = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSharePointIdentitySet(sharePointIdentitySet: Partial<SharePointIdentitySet> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentitySet(sharePointIdentitySet),
        "group": n => { sharePointIdentitySet.group = n.getObjectValue<Identity>(createIdentityFromDiscriminatorValue); },
        "siteGroup": n => { sharePointIdentitySet.siteGroup = n.getObjectValue<SharePointIdentity>(createSharePointIdentityFromDiscriminatorValue); },
        "siteUser": n => { sharePointIdentitySet.siteUser = n.getObjectValue<SharePointIdentity>(createSharePointIdentityFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSingleValueLegacyExtendedProperty(singleValueLegacyExtendedProperty: Partial<SingleValueLegacyExtendedProperty> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(singleValueLegacyExtendedProperty),
        "value": n => { singleValueLegacyExtendedProperty.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoSizeRange(sizeRange: Partial<SizeRange> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "maximumSize": n => { sizeRange.maximumSize = n.getNumberValue(); },
        "minimumSize": n => { sizeRange.minimumSize = n.getNumberValue(); },
        "@odata.type": n => { sizeRange.odataType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTabUpdatedEventMessageDetail(tabUpdatedEventMessageDetail: Partial<TabUpdatedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(tabUpdatedEventMessageDetail),
        "initiator": n => { tabUpdatedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "tabId": n => { tabUpdatedEventMessageDetail.tabId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTeamArchivedEventMessageDetail(teamArchivedEventMessageDetail: Partial<TeamArchivedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(teamArchivedEventMessageDetail),
        "initiator": n => { teamArchivedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "teamId": n => { teamArchivedEventMessageDetail.teamId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTeamCreatedEventMessageDetail(teamCreatedEventMessageDetail: Partial<TeamCreatedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(teamCreatedEventMessageDetail),
        "initiator": n => { teamCreatedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "teamDescription": n => { teamCreatedEventMessageDetail.teamDescription = n.getStringValue(); },
        "teamDisplayName": n => { teamCreatedEventMessageDetail.teamDisplayName = n.getStringValue(); },
        "teamId": n => { teamCreatedEventMessageDetail.teamId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTeamDescriptionUpdatedEventMessageDetail(teamDescriptionUpdatedEventMessageDetail: Partial<TeamDescriptionUpdatedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(teamDescriptionUpdatedEventMessageDetail),
        "initiator": n => { teamDescriptionUpdatedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "teamDescription": n => { teamDescriptionUpdatedEventMessageDetail.teamDescription = n.getStringValue(); },
        "teamId": n => { teamDescriptionUpdatedEventMessageDetail.teamId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTeamJoiningDisabledEventMessageDetail(teamJoiningDisabledEventMessageDetail: Partial<TeamJoiningDisabledEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(teamJoiningDisabledEventMessageDetail),
        "initiator": n => { teamJoiningDisabledEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "teamId": n => { teamJoiningDisabledEventMessageDetail.teamId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTeamJoiningEnabledEventMessageDetail(teamJoiningEnabledEventMessageDetail: Partial<TeamJoiningEnabledEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(teamJoiningEnabledEventMessageDetail),
        "initiator": n => { teamJoiningEnabledEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "teamId": n => { teamJoiningEnabledEventMessageDetail.teamId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTeamRenamedEventMessageDetail(teamRenamedEventMessageDetail: Partial<TeamRenamedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(teamRenamedEventMessageDetail),
        "initiator": n => { teamRenamedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "teamDisplayName": n => { teamRenamedEventMessageDetail.teamDisplayName = n.getStringValue(); },
        "teamId": n => { teamRenamedEventMessageDetail.teamId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTeamsAppInstalledEventMessageDetail(teamsAppInstalledEventMessageDetail: Partial<TeamsAppInstalledEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(teamsAppInstalledEventMessageDetail),
        "initiator": n => { teamsAppInstalledEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "teamsAppDisplayName": n => { teamsAppInstalledEventMessageDetail.teamsAppDisplayName = n.getStringValue(); },
        "teamsAppId": n => { teamsAppInstalledEventMessageDetail.teamsAppId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTeamsAppRemovedEventMessageDetail(teamsAppRemovedEventMessageDetail: Partial<TeamsAppRemovedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(teamsAppRemovedEventMessageDetail),
        "initiator": n => { teamsAppRemovedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "teamsAppDisplayName": n => { teamsAppRemovedEventMessageDetail.teamsAppDisplayName = n.getStringValue(); },
        "teamsAppId": n => { teamsAppRemovedEventMessageDetail.teamsAppId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTeamsAppUpgradedEventMessageDetail(teamsAppUpgradedEventMessageDetail: Partial<TeamsAppUpgradedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(teamsAppUpgradedEventMessageDetail),
        "initiator": n => { teamsAppUpgradedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "teamsAppDisplayName": n => { teamsAppUpgradedEventMessageDetail.teamsAppDisplayName = n.getStringValue(); },
        "teamsAppId": n => { teamsAppUpgradedEventMessageDetail.teamsAppId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTeamUnarchivedEventMessageDetail(teamUnarchivedEventMessageDetail: Partial<TeamUnarchivedEventMessageDetail> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEventMessageDetail(teamUnarchivedEventMessageDetail),
        "initiator": n => { teamUnarchivedEventMessageDetail.initiator = n.getObjectValue<IdentitySet>(createIdentitySetFromDiscriminatorValue); },
        "teamId": n => { teamUnarchivedEventMessageDetail.teamId = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTeamworkApplicationIdentity(teamworkApplicationIdentity: Partial<TeamworkApplicationIdentity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(teamworkApplicationIdentity),
        "applicationIdentityType": n => { teamworkApplicationIdentity.applicationIdentityType = n.getEnumValue<TeamworkApplicationIdentityType>(TeamworkApplicationIdentityTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTeamworkConversationIdentity(teamworkConversationIdentity: Partial<TeamworkConversationIdentity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(teamworkConversationIdentity),
        "conversationIdentityType": n => { teamworkConversationIdentity.conversationIdentityType = n.getEnumValue<TeamworkConversationIdentityType>(TeamworkConversationIdentityTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTeamworkHostedContent(teamworkHostedContent: Partial<TeamworkHostedContent> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoEntity(teamworkHostedContent),
        "contentBytes": n => { teamworkHostedContent.contentBytes = n.getStringValue(); },
        "contentType": n => { teamworkHostedContent.contentType = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTeamworkTagIdentity(teamworkTagIdentity: Partial<TeamworkTagIdentity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(teamworkTagIdentity),
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTeamworkUserIdentity(teamworkUserIdentity: Partial<TeamworkUserIdentity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(teamworkUserIdentity),
        "userIdentityType": n => { teamworkUserIdentity.userIdentityType = n.getEnumValue<TeamworkUserIdentityType>(TeamworkUserIdentityTypeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoTimeSlot(timeSlot: Partial<TimeSlot> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "end": n => { timeSlot.end = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
        "@odata.type": n => { timeSlot.odataType = n.getStringValue(); },
        "start": n => { timeSlot.start = n.getObjectValue<DateTimeTimeZone>(createDateTimeTimeZoneFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
export function deserializeIntoUserIdentity(userIdentity: Partial<UserIdentity> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIdentity(userIdentity),
        "ipAddress": n => { userIdentity.ipAddress = n.getStringValue(); },
        "userPrincipalName": n => { userIdentity.userPrincipalName = n.getStringValue(); },
    }
}
export interface DetailsInfo extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface EmailAddress extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The email address of the person or entity.
     */
    address?: string;
    /**
     * The display name of the person or entity.
     */
    name?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface EmailIdentity extends Identity, Parsable {
    /**
     * Email address of the user.
     */
    email?: string;
}
export type EndpointType = (typeof EndpointTypeObject)[keyof typeof EndpointTypeObject];
export interface Entity extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The unique identifier for an entity. Read-only.
     */
    id?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface Event extends OutlookItem, Parsable {
    /**
     * true if the meeting organizer allows invitees to propose a new time when responding; otherwise, false. Optional. Default is true.
     */
    allowNewTimeProposals?: boolean;
    /**
     * The collection of FileAttachment, ItemAttachment, and referenceAttachment attachments for the event. Navigation property. Read-only. Nullable.
     */
    attachments?: Attachment[];
    /**
     * The collection of attendees for the event.
     */
    attendees?: Attendee[];
    /**
     * The body of the message associated with the event. It can be in HTML or text format.
     */
    body?: ItemBody;
    /**
     * The preview of the message associated with the event. It is in text format.
     */
    bodyPreview?: string;
    /**
     * The calendar that contains the event. Navigation property. Read-only.
     */
    calendar?: Calendar;
    /**
     * The date, time, and time zone that the event ends. By default, the end time is in UTC.
     */
    end?: DateTimeTimeZone;
    /**
     * The collection of open extensions defined for the event. Nullable.
     */
    extensions?: Extension[];
    /**
     * Set to true if the event has attachments.
     */
    hasAttachments?: boolean;
    /**
     * When set to true, each attendee only sees themselves in the meeting request and meeting Tracking list. Default is false.
     */
    hideAttendees?: boolean;
    /**
     * A unique identifier for an event across calendars. This ID is different for each occurrence in a recurring series. Read-only.
     */
    iCalUId?: string;
    /**
     * The importance of the event. The possible values are: low, normal, high.
     */
    importance?: Importance;
    /**
     * The occurrences of a recurring series, if the event is a series master. This property includes occurrences that are part of the recurrence pattern, and exceptions that have been modified, but does not include occurrences that have been cancelled from the series. Navigation property. Read-only. Nullable.
     */
    instances?: Event[];
    /**
     * Set to true if the event lasts all day. If true, regardless of whether it's a single-day or multi-day event, start and end time must be set to midnight and be in the same time zone.
     */
    isAllDay?: boolean;
    /**
     * Set to true if the event has been canceled.
     */
    isCancelled?: boolean;
    /**
     * Set to true if the user has updated the meeting in Outlook but has not sent the updates to attendees. Set to false if all changes have been sent, or if the event is an appointment without any attendees.
     */
    isDraft?: boolean;
    /**
     * True if this event has online meeting information (that is, onlineMeeting points to an onlineMeetingInfo resource), false otherwise. Default is false (onlineMeeting is null). Optional.  After you set isOnlineMeeting to true, Microsoft Graph initializes onlineMeeting. Subsequently Outlook ignores any further changes to isOnlineMeeting, and the meeting remains available online.
     */
    isOnlineMeeting?: boolean;
    /**
     * Set to true if the calendar owner (specified by the owner property of the calendar) is the organizer of the event (specified by the organizer property of the event). This also applies if a delegate organized the event on behalf of the owner.
     */
    isOrganizer?: boolean;
    /**
     * Set to true if an alert is set to remind the user of the event.
     */
    isReminderOn?: boolean;
    /**
     * The location of the event.
     */
    location?: Location;
    /**
     * The locations where the event is held or attended from. The location and locations properties always correspond with each other. If you update the location property, any prior locations in the locations collection would be removed and replaced by the new location value.
     */
    locations?: Location[];
    /**
     * The collection of multi-value extended properties defined for the event. Read-only. Nullable.
     */
    multiValueExtendedProperties?: MultiValueLegacyExtendedProperty[];
    /**
     * Details for an attendee to join the meeting online. Default is null. Read-only. After you set the isOnlineMeeting and onlineMeetingProvider properties to enable a meeting online, Microsoft Graph initializes onlineMeeting. When set, the meeting remains available online, and you cannot change the isOnlineMeeting, onlineMeetingProvider, and onlneMeeting properties again.
     */
    onlineMeeting?: OnlineMeetingInfo;
    /**
     * Represents the online meeting service provider. By default, onlineMeetingProvider is unknown. The possible values are unknown, teamsForBusiness, skypeForBusiness, and skypeForConsumer. Optional.  After you set onlineMeetingProvider, Microsoft Graph initializes onlineMeeting. Subsequently you cannot change onlineMeetingProvider again, and the meeting remains available online.
     */
    onlineMeetingProvider?: OnlineMeetingProviderType;
    /**
     * A URL for an online meeting. The property is set only when an organizer specifies in Outlook that an event is an online meeting such as Skype. Read-only.To access the URL to join an online meeting, use joinUrl which is exposed via the onlineMeeting property of the event. The onlineMeetingUrl property will be deprecated in the future.
     */
    onlineMeetingUrl?: string;
    /**
     * The organizer of the event.
     */
    organizer?: Recipient;
    /**
     * The end time zone that was set when the event was created. A value of tzone://Microsoft/Custom indicates that a legacy custom time zone was set in desktop Outlook.
     */
    originalEndTimeZone?: string;
    /**
     * Represents the start time of an event when it is initially created as an occurrence or exception in a recurring series. This property is not returned for events that are single instances. Its date and time information is expressed in ISO 8601 format and is always in UTC. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    originalStart?: Date;
    /**
     * The start time zone that was set when the event was created. A value of tzone://Microsoft/Custom indicates that a legacy custom time zone was set in desktop Outlook.
     */
    originalStartTimeZone?: string;
    /**
     * The recurrence pattern for the event.
     */
    recurrence?: PatternedRecurrence;
    /**
     * The number of minutes before the event start time that the reminder alert occurs.
     */
    reminderMinutesBeforeStart?: number;
    /**
     * Default is true, which represents the organizer would like an invitee to send a response to the event.
     */
    responseRequested?: boolean;
    /**
     * Indicates the type of response sent in response to an event message.
     */
    responseStatus?: ResponseStatus;
    /**
     * Possible values are: normal, personal, private, confidential.
     */
    sensitivity?: Sensitivity;
    /**
     * The ID for the recurring series master item, if this event is part of a recurring series.
     */
    seriesMasterId?: string;
    /**
     * The status to show. Possible values are: free, tentative, busy, oof, workingElsewhere, unknown.
     */
    showAs?: FreeBusyStatus;
    /**
     * The collection of single-value extended properties defined for the event. Read-only. Nullable.
     */
    singleValueExtendedProperties?: SingleValueLegacyExtendedProperty[];
    /**
     * The start date, time, and time zone of the event. By default, the start time is in UTC.
     */
    start?: DateTimeTimeZone;
    /**
     * The text of the event's subject line.
     */
    subject?: string;
    /**
     * A custom identifier specified by a client app for the server to avoid redundant POST operations in case of client retries to create the same event. This is useful when low network connectivity causes the client to time out before receiving a response from the server for the client's prior create-event request. After you set transactionId when creating an event, you cannot change transactionId in a subsequent update. This property is only returned in a response payload if an app has set it. Optional.
     */
    transactionId?: string;
    /**
     * The event type. Possible values are: singleInstance, occurrence, exception, seriesMaster. Read-only
     */
    type?: EventType;
    /**
     * The URL to open the event in Outlook on the web.Outlook on the web opens the event in the browser if you are signed in to your mailbox. Otherwise, Outlook on the web prompts you to sign in.This URL cannot be accessed from within an iFrame.
     */
    webLink?: string;
}
export interface EventMessage extends Message, Parsable {
    /**
     * The endDateTime property
     */
    endDateTime?: DateTimeTimeZone;
    /**
     * The event associated with the event message. The assumption for attendees or room resources is that the Calendar Attendant is set to automatically update the calendar with an event when meeting request event messages arrive. Navigation property.  Read-only.
     */
    event?: Event;
    /**
     * The isAllDay property
     */
    isAllDay?: boolean;
    /**
     * True if this meeting request is accessible to a delegate, false otherwise. Default is false.
     */
    isDelegated?: boolean;
    /**
     * The isOutOfDate property
     */
    isOutOfDate?: boolean;
    /**
     * The location property
     */
    location?: Location;
    /**
     * The type of event message: none, meetingRequest, meetingCancelled, meetingAccepted, meetingTenativelyAccepted, meetingDeclined.
     */
    meetingMessageType?: MeetingMessageType;
    /**
     * The recurrence property
     */
    recurrence?: PatternedRecurrence;
    /**
     * The startDateTime property
     */
    startDateTime?: DateTimeTimeZone;
    /**
     * The type property
     */
    type?: EventType;
}
export interface EventMessageDetail extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface EventMessageRequest extends EventMessage, Parsable {
    /**
     * True if the meeting organizer allows invitees to propose a new time when responding, false otherwise. Optional. Default is true.
     */
    allowNewTimeProposals?: boolean;
    /**
     * The meetingRequestType property
     */
    meetingRequestType?: MeetingRequestType;
    /**
     * If the meeting update changes the meeting end time, this property specifies the previous meeting end time.
     */
    previousEndDateTime?: DateTimeTimeZone;
    /**
     * If the meeting update changes the meeting location, this property specifies the previous meeting location.
     */
    previousLocation?: Location;
    /**
     * If the meeting update changes the meeting start time, this property specifies the previous meeting start time.
     */
    previousStartDateTime?: DateTimeTimeZone;
    /**
     * Set to true if the sender would like the invitee to send a response to the requested meeting.
     */
    responseRequested?: boolean;
}
export interface EventMessageResponse extends EventMessage, Parsable {
    /**
     * An alternate date/time proposed by an invitee for a meeting request to start and end. Read-only. Not filterable.
     */
    proposedNewTime?: TimeSlot;
    /**
     * Specifies the type of response to a meeting request. Possible values are: tentativelyAccepted, accepted, declined. For the eventMessageResponse type, none, organizer, and notResponded are not supported. Read-only. Not filterable.
     */
    responseType?: ResponseType;
}
export type EventType = (typeof EventTypeObject)[keyof typeof EventTypeObject];
export interface Extension extends Entity, Parsable {
}
export interface FileAttachment extends Attachment, Parsable {
    /**
     * The base64-encoded contents of the file.
     */
    contentBytes?: string;
    /**
     * The ID of the attachment in the Exchange store.
     */
    contentId?: string;
    /**
     * Don't use this property as it isn't supported.
     */
    contentLocation?: string;
}
export interface FollowupFlag extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The date and time that the follow-up was finished.
     */
    completedDateTime?: DateTimeTimeZone;
    /**
     * The date and time that the follow-up is to be finished. Note: To set the due date, you must also specify the startDateTime; otherwise, you get a 400 Bad Request response.
     */
    dueDateTime?: DateTimeTimeZone;
    /**
     * The status for follow-up for an item. Possible values are notFlagged, complete, and flagged.
     */
    flagStatus?: FollowupFlagStatus;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The date and time that the follow-up is to begin.
     */
    startDateTime?: DateTimeTimeZone;
}
export type FollowupFlagStatus = (typeof FollowupFlagStatusObject)[keyof typeof FollowupFlagStatusObject];
export type FreeBusyStatus = (typeof FreeBusyStatusObject)[keyof typeof FreeBusyStatusObject];
export interface Identity extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The display name of the identity.For drive items, the display name might not always be available or up to date. For example, if a user changes their display name the API might show the new value in a future response, but the items associated with the user don't show up as changed when using delta.
     */
    displayName?: string;
    /**
     * Unique identifier for the identity or actor. For example, in the access reviews decisions API, this property might record the id of the principal, that is, the group, user, or application that's subject to review.
     */
    id?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface IdentitySet extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Optional. The application associated with this action.
     */
    application?: Identity;
    /**
     * Optional. The device associated with this action.
     */
    device?: Identity;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Optional. The user associated with this action.
     */
    user?: Identity;
}
export type Importance = (typeof ImportanceObject)[keyof typeof ImportanceObject];
export type InferenceClassificationType = (typeof InferenceClassificationTypeObject)[keyof typeof InferenceClassificationTypeObject];
export interface Initiator extends Identity, Parsable {
    /**
     * Type of initiator. Possible values are: user, application, system, unknownFutureValue.
     */
    initiatorType?: InitiatorType;
}
export type InitiatorType = (typeof InitiatorTypeObject)[keyof typeof InitiatorTypeObject];
export interface InternetMessageHeader extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Represents the key in a key-value pair.
     */
    name?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The value in a key-value pair.
     */
    value?: string;
}
export interface ItemAttachment extends Attachment, Parsable {
    /**
     * The attached message or event. Navigation property.
     */
    item?: OutlookItem;
}
export interface ItemBody extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The content of the item.
     */
    content?: string;
    /**
     * The type of the content. Possible values are text and html.
     */
    contentType?: BodyType;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface Location extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The street address of the location.
     */
    address?: PhysicalAddress;
    /**
     * The geographic coordinates and elevation of the location.
     */
    coordinates?: OutlookGeoCoordinates;
    /**
     * The name associated with the location.
     */
    displayName?: string;
    /**
     * Optional email address of the location.
     */
    locationEmailAddress?: string;
    /**
     * The type of location. The possible values are: default, conferenceRoom, homeAddress, businessAddress,geoCoordinates, streetAddress, hotel, restaurant, localBusiness, postalAddress. Read-only.
     */
    locationType?: LocationType;
    /**
     * Optional URI representing the location.
     */
    locationUri?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * For internal use only.
     */
    uniqueId?: string;
    /**
     * For internal use only.
     */
    uniqueIdType?: LocationUniqueIdType;
}
export interface LocationConstraintItem extends Location, Parsable {
    /**
     * If set to true and the specified resource is busy, findMeetingTimes looks for another resource that is free. If set to false and the specified resource is busy, findMeetingTimes returns the resource best ranked in the user's cache without checking if it's free. Default is true.
     */
    resolveAvailability?: boolean;
}
export type LocationType = (typeof LocationTypeObject)[keyof typeof LocationTypeObject];
export type LocationUniqueIdType = (typeof LocationUniqueIdTypeObject)[keyof typeof LocationUniqueIdTypeObject];
export interface MailFolder extends Entity, Parsable {
    /**
     * The number of immediate child mailFolders in the current mailFolder.
     */
    childFolderCount?: number;
    /**
     * The collection of child folders in the mailFolder.
     */
    childFolders?: MailFolder[];
    /**
     * The mailFolder's display name.
     */
    displayName?: string;
    /**
     * Indicates whether the mailFolder is hidden. This property can be set only when creating the folder. Find more information in Hidden mail folders.
     */
    isHidden?: boolean;
    /**
     * The collection of rules that apply to the user's Inbox folder.
     */
    messageRules?: MessageRule[];
    /**
     * The collection of messages in the mailFolder.
     */
    messages?: Message[];
    /**
     * The collection of multi-value extended properties defined for the mailFolder. Read-only. Nullable.
     */
    multiValueExtendedProperties?: MultiValueLegacyExtendedProperty[];
    /**
     * The unique identifier for the mailFolder's parent mailFolder.
     */
    parentFolderId?: string;
    /**
     * The collection of single-value extended properties defined for the mailFolder. Read-only. Nullable.
     */
    singleValueExtendedProperties?: SingleValueLegacyExtendedProperty[];
    /**
     * The number of items in the mailFolder.
     */
    totalItemCount?: number;
    /**
     * The number of items in the mailFolder marked as unread.
     */
    unreadItemCount?: number;
}
export interface MailFolderCollectionResponse extends BaseCollectionPaginationCountResponse, Parsable {
    /**
     * The value property
     */
    value?: MailFolder[];
}
export interface MailSearchFolder extends MailFolder, Parsable {
    /**
     * The OData query to filter the messages.
     */
    filterQuery?: string;
    /**
     * Indicates how the mailbox folder hierarchy should be traversed in the search. true means that a deep search should be done to include child folders in the hierarchy of each folder explicitly specified in sourceFolderIds. false means a shallow search of only each of the folders explicitly specified in sourceFolderIds.
     */
    includeNestedFolders?: boolean;
    /**
     * Indicates whether a search folder is editable using REST APIs.
     */
    isSupported?: boolean;
    /**
     * The mailbox folders that should be mined.
     */
    sourceFolderIds?: string[];
}
export type MeetingMessageType = (typeof MeetingMessageTypeObject)[keyof typeof MeetingMessageTypeObject];
export interface MeetingPolicyUpdatedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
    /**
     * Represents whether the meeting chat is enabled or not.
     */
    meetingChatEnabled?: boolean;
    /**
     * Unique identifier of the meeting chat.
     */
    meetingChatId?: string;
}
export type MeetingRequestType = (typeof MeetingRequestTypeObject)[keyof typeof MeetingRequestTypeObject];
export interface MembersAddedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
    /**
     * List of members added.
     */
    members?: TeamworkUserIdentity[];
    /**
     * The timestamp that denotes how far back a conversation's history is shared with the conversation members.
     */
    visibleHistoryStartDateTime?: Date;
}
export interface MembersDeletedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
    /**
     * List of members deleted.
     */
    members?: TeamworkUserIdentity[];
}
export interface MembersJoinedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
    /**
     * List of members who joined the chat.
     */
    members?: TeamworkUserIdentity[];
}
export interface MembersLeftEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
    /**
     * List of members who left the chat.
     */
    members?: TeamworkUserIdentity[];
}
export interface Message extends OutlookItem, Parsable {
    /**
     * The fileAttachment and itemAttachment attachments for the message.
     */
    attachments?: Attachment[];
    /**
     * The Bcc: recipients for the message.
     */
    bccRecipients?: Recipient[];
    /**
     * The body of the message. It can be in HTML or text format. Find out about safe HTML in a message body.
     */
    body?: ItemBody;
    /**
     * The first 255 characters of the message body. It is in text format.
     */
    bodyPreview?: string;
    /**
     * The Cc: recipients for the message.
     */
    ccRecipients?: Recipient[];
    /**
     * The ID of the conversation the email belongs to.
     */
    conversationId?: string;
    /**
     * Indicates the position of the message within the conversation.
     */
    conversationIndex?: string;
    /**
     * The collection of open extensions defined for the message. Nullable.
     */
    extensions?: Extension[];
    /**
     * The flag value that indicates the status, start date, due date, or completion date for the message.
     */
    flag?: FollowupFlag;
    /**
     * The owner of the mailbox from which the message is sent. In most cases, this value is the same as the sender property, except for sharing or delegation scenarios. The value must correspond to the actual mailbox used. Find out more about setting the from and sender properties of a message.
     */
    from?: Recipient;
    /**
     * Indicates whether the message has attachments. This property doesn't include inline attachments, so if a message contains only inline attachments, this property is false. To verify the existence of inline attachments, parse the body property to look for a src attribute, such as <IMG src='cid:image001.jpg@01D26CD8.6C05F070'>.
     */
    hasAttachments?: boolean;
    /**
     * The importance of the message. The possible values are: low, normal, and high.
     */
    importance?: Importance;
    /**
     * The classification of the message for the user, based on inferred relevance or importance, or on an explicit override. The possible values are: focused or other.
     */
    inferenceClassification?: InferenceClassificationType;
    /**
     * A collection of message headers defined by RFC5322. The set includes message headers indicating the network path taken by a message from the sender to the recipient. It can also contain custom message headers that hold app data for the message.  Returned only on applying a $select query option. Read-only.
     */
    internetMessageHeaders?: InternetMessageHeader[];
    /**
     * The message ID in the format specified by RFC2822.
     */
    internetMessageId?: string;
    /**
     * Indicates whether a read receipt is requested for the message.
     */
    isDeliveryReceiptRequested?: boolean;
    /**
     * Indicates whether the message is a draft. A message is a draft if it hasn't been sent yet.
     */
    isDraft?: boolean;
    /**
     * Indicates whether the message has been read.
     */
    isRead?: boolean;
    /**
     * Indicates whether a read receipt is requested for the message.
     */
    isReadReceiptRequested?: boolean;
    /**
     * The collection of multi-value extended properties defined for the message. Nullable.
     */
    multiValueExtendedProperties?: MultiValueLegacyExtendedProperty[];
    /**
     * The unique identifier for the message's parent mailFolder.
     */
    parentFolderId?: string;
    /**
     * The date and time the message was received.  The date and time information uses ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    receivedDateTime?: Date;
    /**
     * The email addresses to use when replying.
     */
    replyTo?: Recipient[];
    /**
     * The account that is actually used to generate the message. In most cases, this value is the same as the from property. You can set this property to a different value when sending a message from a shared mailbox, for a shared calendar, or as a delegate. In any case, the value must correspond to the actual mailbox used. Find out more about setting the from and sender properties of a message.
     */
    sender?: Recipient;
    /**
     * The date and time the message was sent.  The date and time information uses ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z.
     */
    sentDateTime?: Date;
    /**
     * The collection of single-value extended properties defined for the message. Nullable.
     */
    singleValueExtendedProperties?: SingleValueLegacyExtendedProperty[];
    /**
     * The subject of the message.
     */
    subject?: string;
    /**
     * The To: recipients for the message.
     */
    toRecipients?: Recipient[];
    /**
     * The part of the body of the message that is unique to the current message. uniqueBody is not returned by default but can be retrieved for a given message by use of the ?$select=uniqueBody query. It can be in HTML or text format.
     */
    uniqueBody?: ItemBody;
    /**
     * The URL to open the message in Outlook on the web.You can append an ispopout argument to the end of the URL to change how the message is displayed. If ispopout is not present or if it is set to 1, then the message is shown in a popout window. If ispopout is set to 0, the browser shows the message in the Outlook on the web review pane.The message opens in the browser if you are signed in to your mailbox via Outlook on the web. You are prompted to sign in if you are not already signed in with the browser.This URL cannot be accessed from within an iFrame.
     */
    webLink?: string;
}
export type MessageActionFlag = (typeof MessageActionFlagObject)[keyof typeof MessageActionFlagObject];
export interface MessagePinnedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Date and time when the event occurred.
     */
    eventDateTime?: Date;
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
}
export interface MessageRule extends Entity, Parsable {
    /**
     * Actions to be taken on a message when the corresponding conditions are fulfilled.
     */
    actions?: MessageRuleActions;
    /**
     * Conditions that when fulfilled trigger the corresponding actions for that rule.
     */
    conditions?: MessageRulePredicates;
    /**
     * The display name of the rule.
     */
    displayName?: string;
    /**
     * Exception conditions for the rule.
     */
    exceptions?: MessageRulePredicates;
    /**
     * Indicates whether the rule is in an error condition. Read-only.
     */
    hasError?: boolean;
    /**
     * Indicates whether the rule is enabled to be applied to messages.
     */
    isEnabled?: boolean;
    /**
     * Indicates if the rule is read-only and cannot be modified or deleted by the rules REST API.
     */
    isReadOnly?: boolean;
    /**
     * Indicates the order in which the rule is executed, among other rules.
     */
    sequence?: number;
}
export interface MessageRuleActions extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * A list of categories to be assigned to a message.
     */
    assignCategories?: string[];
    /**
     * The ID of a folder that a message is to be copied to.
     */
    copyToFolder?: string;
    /**
     * Indicates whether a message should be moved to the Deleted Items folder.
     */
    delete?: boolean;
    /**
     * The email addresses of the recipients to which a message should be forwarded as an attachment.
     */
    forwardAsAttachmentTo?: Recipient[];
    /**
     * The email addresses of the recipients to which a message should be forwarded.
     */
    forwardTo?: Recipient[];
    /**
     * Indicates whether a message should be marked as read.
     */
    markAsRead?: boolean;
    /**
     * Sets the importance of the message, which can be: low, normal, high.
     */
    markImportance?: Importance;
    /**
     * The ID of the folder that a message will be moved to.
     */
    moveToFolder?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Indicates whether a message should be permanently deleted and not saved to the Deleted Items folder.
     */
    permanentDelete?: boolean;
    /**
     * The email addresses to which a message should be redirected.
     */
    redirectTo?: Recipient[];
    /**
     * Indicates whether subsequent rules should be evaluated.
     */
    stopProcessingRules?: boolean;
}
export interface MessageRulePredicates extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * Represents the strings that should appear in the body of an incoming message in order for the condition or exception to apply.
     */
    bodyContains?: string[];
    /**
     * Represents the strings that should appear in the body or subject of an incoming message in order for the condition or exception to apply.
     */
    bodyOrSubjectContains?: string[];
    /**
     * Represents the categories that an incoming message should be labeled with in order for the condition or exception to apply.
     */
    categories?: string[];
    /**
     * Represents the specific sender email addresses of an incoming message in order for the condition or exception to apply.
     */
    fromAddresses?: Recipient[];
    /**
     * Indicates whether an incoming message must have attachments in order for the condition or exception to apply.
     */
    hasAttachments?: boolean;
    /**
     * Represents the strings that appear in the headers of an incoming message in order for the condition or exception to apply.
     */
    headerContains?: string[];
    /**
     * The importance that is stamped on an incoming message in order for the condition or exception to apply: low, normal, high.
     */
    importance?: Importance;
    /**
     * Indicates whether an incoming message must be an approval request in order for the condition or exception to apply.
     */
    isApprovalRequest?: boolean;
    /**
     * Indicates whether an incoming message must be automatically forwarded in order for the condition or exception to apply.
     */
    isAutomaticForward?: boolean;
    /**
     * Indicates whether an incoming message must be an auto reply in order for the condition or exception to apply.
     */
    isAutomaticReply?: boolean;
    /**
     * Indicates whether an incoming message must be encrypted in order for the condition or exception to apply.
     */
    isEncrypted?: boolean;
    /**
     * Indicates whether an incoming message must be a meeting request in order for the condition or exception to apply.
     */
    isMeetingRequest?: boolean;
    /**
     * Indicates whether an incoming message must be a meeting response in order for the condition or exception to apply.
     */
    isMeetingResponse?: boolean;
    /**
     * Indicates whether an incoming message must be a non-delivery report in order for the condition or exception to apply.
     */
    isNonDeliveryReport?: boolean;
    /**
     * Indicates whether an incoming message must be permission controlled (RMS-protected) in order for the condition or exception to apply.
     */
    isPermissionControlled?: boolean;
    /**
     * Indicates whether an incoming message must be a read receipt in order for the condition or exception to apply.
     */
    isReadReceipt?: boolean;
    /**
     * Indicates whether an incoming message must be S/MIME-signed in order for the condition or exception to apply.
     */
    isSigned?: boolean;
    /**
     * Indicates whether an incoming message must be a voice mail in order for the condition or exception to apply.
     */
    isVoicemail?: boolean;
    /**
     * Represents the flag-for-action value that appears on an incoming message in order for the condition or exception to apply. The possible values are: any, call, doNotForward, followUp, fyi, forward, noResponseNecessary, read, reply, replyToAll, review.
     */
    messageActionFlag?: MessageActionFlag;
    /**
     * Indicates whether the owner of the mailbox must not be a recipient of an incoming message in order for the condition or exception to apply.
     */
    notSentToMe?: boolean;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Represents the strings that appear in either the toRecipients or ccRecipients properties of an incoming message in order for the condition or exception to apply.
     */
    recipientContains?: string[];
    /**
     * Represents the strings that appear in the from property of an incoming message in order for the condition or exception to apply.
     */
    senderContains?: string[];
    /**
     * Represents the sensitivity level that must be stamped on an incoming message in order for the condition or exception to apply. The possible values are: normal, personal, private, confidential.
     */
    sensitivity?: Sensitivity;
    /**
     * Indicates whether the owner of the mailbox must be in the ccRecipients property of an incoming message in order for the condition or exception to apply.
     */
    sentCcMe?: boolean;
    /**
     * Indicates whether the owner of the mailbox must be the only recipient in an incoming message in order for the condition or exception to apply.
     */
    sentOnlyToMe?: boolean;
    /**
     * Represents the email addresses that an incoming message must have been sent to in order for the condition or exception to apply.
     */
    sentToAddresses?: Recipient[];
    /**
     * Indicates whether the owner of the mailbox must be in the toRecipients property of an incoming message in order for the condition or exception to apply.
     */
    sentToMe?: boolean;
    /**
     * Indicates whether the owner of the mailbox must be in either a toRecipients or ccRecipients property of an incoming message in order for the condition or exception to apply.
     */
    sentToOrCcMe?: boolean;
    /**
     * Represents the strings that appear in the subject of an incoming message in order for the condition or exception to apply.
     */
    subjectContains?: string[];
    /**
     * Represents the minimum and maximum sizes (in kilobytes) that an incoming message must fall in between in order for the condition or exception to apply.
     */
    withinSizeRange?: SizeRange;
}
export interface MessageUnpinnedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Date and time when the event occurred.
     */
    eventDateTime?: Date;
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
}
export interface MultiValueLegacyExtendedProperty extends Entity, Parsable {
    /**
     * A collection of property values.
     */
    value?: string[];
}
export interface OnlineMeetingInfo extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The ID of the conference.
     */
    conferenceId?: string;
    /**
     * The external link that launches the online meeting. This is a URL that clients launch into a browser and will redirect the user to join the meeting.
     */
    joinUrl?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * All of the phone numbers associated with this conference.
     */
    phones?: Phone[];
    /**
     * The preformatted quick dial for this call.
     */
    quickDial?: string;
    /**
     * The toll free numbers that can be used to join the conference.
     */
    tollFreeNumbers?: string[];
    /**
     * The toll number that can be used to join the conference.
     */
    tollNumber?: string;
}
export type OnlineMeetingProviderType = (typeof OnlineMeetingProviderTypeObject)[keyof typeof OnlineMeetingProviderTypeObject];
export interface OpenTypeExtension extends Extension, Parsable {
    /**
     * A unique text identifier for an open type data extension. Optional.
     */
    extensionName?: string;
}
export interface OutlookGeoCoordinates extends AdditionalDataHolder, Parsable {
    /**
     * The accuracy of the latitude and longitude. As an example, the accuracy can be measured in meters, such as the latitude and longitude are accurate to within 50 meters.
     */
    accuracy?: number;
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The altitude of the location.
     */
    altitude?: number;
    /**
     * The accuracy of the altitude.
     */
    altitudeAccuracy?: number;
    /**
     * The latitude of the location.
     */
    latitude?: number;
    /**
     * The longitude of the location.
     */
    longitude?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface OutlookItem extends Entity, Parsable {
    /**
     * The categories associated with the item
     */
    categories?: string[];
    /**
     * Identifies the version of the item. Every time the item is changed, changeKey changes as well. This allows Exchange to apply changes to the correct version of the object. Read-only.
     */
    changeKey?: string;
    /**
     * The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    createdDateTime?: Date;
    /**
     * The Timestamp type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    lastModifiedDateTime?: Date;
}
export interface PatternedRecurrence extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The frequency of an event.  For access reviews: Do not specify this property for a one-time access review.  Only interval, dayOfMonth, and type (weekly, absoluteMonthly) properties of recurrencePattern are supported.
     */
    pattern?: RecurrencePattern;
    /**
     * The duration of an event.
     */
    range?: RecurrenceRange;
}
export interface Phone extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The language property
     */
    language?: string;
    /**
     * The phone number.
     */
    number?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The region property
     */
    region?: string;
    /**
     * The type of phone number. The possible values are: home, business, mobile, other, assistant, homeFax, businessFax, otherFax, pager, radio.
     */
    type?: PhoneType;
}
export type PhoneType = (typeof PhoneTypeObject)[keyof typeof PhoneTypeObject];
export interface PhysicalAddress extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The city.
     */
    city?: string;
    /**
     * The country or region. It's a free-format string value, for example, 'United States'.
     */
    countryOrRegion?: string;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The postal code.
     */
    postalCode?: string;
    /**
     * The state.
     */
    state?: string;
    /**
     * The street.
     */
    street?: string;
}
export interface Post extends OutlookItem, Parsable {
    /**
     * Read-only. Nullable. Supports $expand.
     */
    attachments?: Attachment[];
    /**
     * The contents of the post. This is a default property. This property can be null.
     */
    body?: ItemBody;
    /**
     * Unique ID of the conversation. Read-only.
     */
    conversationId?: string;
    /**
     * Unique ID of the conversation thread. Read-only.
     */
    conversationThreadId?: string;
    /**
     * The collection of open extensions defined for the post. Read-only. Nullable. Supports $expand.
     */
    extensions?: Extension[];
    /**
     * The from property
     */
    from?: Recipient;
    /**
     * Indicates whether the post has at least one attachment. This is a default property.
     */
    hasAttachments?: boolean;
    /**
     * Read-only. Supports $expand.
     */
    inReplyTo?: Post;
    /**
     * The collection of multi-value extended properties defined for the post. Read-only. Nullable.
     */
    multiValueExtendedProperties?: MultiValueLegacyExtendedProperty[];
    /**
     * Conversation participants that were added to the thread as part of this post.
     */
    newParticipants?: Recipient[];
    /**
     * Specifies when the post was received. The DateTimeOffset type represents date and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    receivedDateTime?: Date;
    /**
     * Contains the address of the sender. The value of Sender is assumed to be the address of the authenticated user in the case when Sender is not specified. This is a default property.
     */
    sender?: Recipient;
    /**
     * The collection of single-value extended properties defined for the post. Read-only. Nullable.
     */
    singleValueExtendedProperties?: SingleValueLegacyExtendedProperty[];
}
export interface ProfilePhoto extends Entity, Parsable {
    /**
     * The height of the photo. Read-only.
     */
    height?: number;
    /**
     * The width of the photo. Read-only.
     */
    width?: number;
}
export interface ProvisionedIdentity extends Identity, Parsable {
    /**
     * Details of the identity.
     */
    details?: DetailsInfo;
    /**
     * Type of identity that has been provisioned, such as 'user' or 'group'. Supports $filter (eq, contains).
     */
    identityType?: string;
}
export interface ProvisioningServicePrincipal extends Identity, Parsable {
}
export interface ProvisioningSystem extends Identity, Parsable {
    /**
     * Details of the system.
     */
    details?: DetailsInfo;
}
export interface Recipient extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The recipient's email address.
     */
    emailAddress?: EmailAddress;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface RecurrencePattern extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The day of the month on which the event occurs. Required if type is absoluteMonthly or absoluteYearly.
     */
    dayOfMonth?: number;
    /**
     * A collection of the days of the week on which the event occurs. The possible values are: sunday, monday, tuesday, wednesday, thursday, friday, saturday. If type is relativeMonthly or relativeYearly, and daysOfWeek specifies more than one day, the event falls on the first day that satisfies the pattern.  Required if type is weekly, relativeMonthly, or relativeYearly.
     */
    daysOfWeek?: DayOfWeek[];
    /**
     * The first day of the week. The possible values are: sunday, monday, tuesday, wednesday, thursday, friday, saturday. Default is sunday. Required if type is weekly.
     */
    firstDayOfWeek?: DayOfWeek;
    /**
     * Specifies on which instance of the allowed days specified in daysOfWeek the event occurs, counted from the first instance in the month. The possible values are: first, second, third, fourth, last. Default is first. Optional and used if type is relativeMonthly or relativeYearly.
     */
    index?: WeekIndex;
    /**
     * The number of units between occurrences, where units can be in days, weeks, months, or years, depending on the type. Required.
     */
    interval?: number;
    /**
     * The month in which the event occurs.  This is a number from 1 to 12.
     */
    month?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The recurrence pattern type: daily, weekly, absoluteMonthly, relativeMonthly, absoluteYearly, relativeYearly. Required. For more information, see values of type property.
     */
    type?: RecurrencePatternType;
}
export type RecurrencePatternType = (typeof RecurrencePatternTypeObject)[keyof typeof RecurrencePatternTypeObject];
export interface RecurrenceRange extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The date to stop applying the recurrence pattern. Depending on the recurrence pattern of the event, the last occurrence of the meeting may not be this date. Required if type is endDate.
     */
    endDate?: DateOnly;
    /**
     * The number of times to repeat the event. Required and must be positive if type is numbered.
     */
    numberOfOccurrences?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * Time zone for the startDate and endDate properties. Optional. If not specified, the time zone of the event is used.
     */
    recurrenceTimeZone?: string;
    /**
     * The date to start applying the recurrence pattern. The first occurrence of the meeting may be this date or later, depending on the recurrence pattern of the event. Must be the same value as the start property of the recurring event. Required.
     */
    startDate?: DateOnly;
    /**
     * The recurrence range. The possible values are: endDate, noEnd, numbered. Required.
     */
    type?: RecurrenceRangeType;
}
export type RecurrenceRangeType = (typeof RecurrenceRangeTypeObject)[keyof typeof RecurrenceRangeTypeObject];
export interface ReferenceAttachment extends Attachment, Parsable {
}
export interface ResponseStatus extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The response type. Possible values are: none, organizer, tentativelyAccepted, accepted, declined, notResponded.To differentiate between none and notResponded:  none â€“ from organizer's perspective. This value is used when the status of an attendee/participant is reported to the organizer of a meeting.  notResponded â€“ from attendee's perspective. Indicates the attendee has not responded to the meeting request.  Clients can treat notResponded == none.  As an example, if attendee Alex hasn't responded to a meeting request, getting Alex' response status for that event in Alex' calendar returns notResponded. Getting Alex' response from the calendar of any other attendee or the organizer's returns none. Getting the organizer's response for the event in anybody's calendar also returns none.
     */
    response?: ResponseType;
    /**
     * The date and time when the response was returned. It uses ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 is 2014-01-01T00:00:00Z
     */
    time?: Date;
}
export type ResponseType = (typeof ResponseTypeObject)[keyof typeof ResponseTypeObject];
export type Sensitivity = (typeof SensitivityObject)[keyof typeof SensitivityObject];
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAttachment(writer: SerializationWriter, attachment: Partial<Attachment> | undefined = {}) : void {
    serializeEntity(writer, attachment)
    writer.writeStringValue("contentType", attachment.contentType);
    writer.writeBooleanValue("isInline", attachment.isInline);
    writer.writeDateValue("lastModifiedDateTime", attachment.lastModifiedDateTime);
    writer.writeStringValue("name", attachment.name);
    writer.writeNumberValue("size", attachment.size);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAttendee(writer: SerializationWriter, attendee: Partial<Attendee> | undefined = {}) : void {
    serializeAttendeeBase(writer, attendee)
    writer.writeObjectValue<TimeSlot>("proposedNewTime", attendee.proposedNewTime, serializeTimeSlot);
    writer.writeObjectValue<ResponseStatus>("status", attendee.status, serializeResponseStatus);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAttendeeBase(writer: SerializationWriter, attendeeBase: Partial<AttendeeBase> | undefined = {}) : void {
    serializeRecipient(writer, attendeeBase)
    writer.writeEnumValue<AttendeeType>("type", attendeeBase.type);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeAzureCommunicationServicesUserIdentity(writer: SerializationWriter, azureCommunicationServicesUserIdentity: Partial<AzureCommunicationServicesUserIdentity> | undefined = {}) : void {
    serializeIdentity(writer, azureCommunicationServicesUserIdentity)
    writer.writeStringValue("azureCommunicationServicesResourceId", azureCommunicationServicesUserIdentity.azureCommunicationServicesResourceId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeBaseCollectionPaginationCountResponse(writer: SerializationWriter, baseCollectionPaginationCountResponse: Partial<BaseCollectionPaginationCountResponse> | undefined = {}) : void {
    writer.writeNumberValue("@odata.count", baseCollectionPaginationCountResponse.odataCount);
    writer.writeStringValue("@odata.nextLink", baseCollectionPaginationCountResponse.odataNextLink);
    writer.writeAdditionalData(baseCollectionPaginationCountResponse.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeBaseDeltaFunctionResponse(writer: SerializationWriter, baseDeltaFunctionResponse: Partial<BaseDeltaFunctionResponse> | undefined = {}) : void {
    writer.writeStringValue("@odata.deltaLink", baseDeltaFunctionResponse.odataDeltaLink);
    writer.writeStringValue("@odata.nextLink", baseDeltaFunctionResponse.odataNextLink);
    writer.writeAdditionalData(baseDeltaFunctionResponse.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCalendar(writer: SerializationWriter, calendar: Partial<Calendar> | undefined = {}) : void {
    serializeEntity(writer, calendar)
    if(calendar.allowedOnlineMeetingProviders)
    writer.writeEnumValue<OnlineMeetingProviderType>("allowedOnlineMeetingProviders", ...calendar.allowedOnlineMeetingProviders);
    writer.writeCollectionOfObjectValues<CalendarPermission>("calendarPermissions", calendar.calendarPermissions, serializeCalendarPermission);
    writer.writeCollectionOfObjectValues<Event>("calendarView", calendar.calendarView, serializeEvent);
    writer.writeBooleanValue("canEdit", calendar.canEdit);
    writer.writeBooleanValue("canShare", calendar.canShare);
    writer.writeBooleanValue("canViewPrivateItems", calendar.canViewPrivateItems);
    writer.writeStringValue("changeKey", calendar.changeKey);
    writer.writeEnumValue<CalendarColor>("color", calendar.color);
    writer.writeEnumValue<OnlineMeetingProviderType>("defaultOnlineMeetingProvider", calendar.defaultOnlineMeetingProvider);
    writer.writeCollectionOfObjectValues<Event>("events", calendar.events, serializeEvent);
    writer.writeStringValue("hexColor", calendar.hexColor);
    writer.writeBooleanValue("isDefaultCalendar", calendar.isDefaultCalendar);
    writer.writeBooleanValue("isRemovable", calendar.isRemovable);
    writer.writeBooleanValue("isTallyingResponses", calendar.isTallyingResponses);
    writer.writeCollectionOfObjectValues<MultiValueLegacyExtendedProperty>("multiValueExtendedProperties", calendar.multiValueExtendedProperties, serializeMultiValueLegacyExtendedProperty);
    writer.writeStringValue("name", calendar.name);
    writer.writeObjectValue<EmailAddress>("owner", calendar.owner, serializeEmailAddress);
    writer.writeCollectionOfObjectValues<SingleValueLegacyExtendedProperty>("singleValueExtendedProperties", calendar.singleValueExtendedProperties, serializeSingleValueLegacyExtendedProperty);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCalendarPermission(writer: SerializationWriter, calendarPermission: Partial<CalendarPermission> | undefined = {}) : void {
    serializeEntity(writer, calendarPermission)
    if(calendarPermission.allowedRoles)
    writer.writeEnumValue<CalendarRoleType>("allowedRoles", ...calendarPermission.allowedRoles);
    writer.writeObjectValue<EmailAddress>("emailAddress", calendarPermission.emailAddress, serializeEmailAddress);
    writer.writeBooleanValue("isInsideOrganization", calendarPermission.isInsideOrganization);
    writer.writeBooleanValue("isRemovable", calendarPermission.isRemovable);
    writer.writeEnumValue<CalendarRoleType>("role", calendarPermission.role);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCalendarSharingMessage(writer: SerializationWriter, calendarSharingMessage: Partial<CalendarSharingMessage> | undefined = {}) : void {
    serializeMessage(writer, calendarSharingMessage)
    writer.writeBooleanValue("canAccept", calendarSharingMessage.canAccept);
    writer.writeObjectValue<CalendarSharingMessageAction>("sharingMessageAction", calendarSharingMessage.sharingMessageAction, serializeCalendarSharingMessageAction);
    writer.writeCollectionOfObjectValues<CalendarSharingMessageAction>("sharingMessageActions", calendarSharingMessage.sharingMessageActions, serializeCalendarSharingMessageAction);
    writer.writeStringValue("suggestedCalendarName", calendarSharingMessage.suggestedCalendarName);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCalendarSharingMessageAction(writer: SerializationWriter, calendarSharingMessageAction: Partial<CalendarSharingMessageAction> | undefined = {}) : void {
    writer.writeEnumValue<CalendarSharingAction>("action", calendarSharingMessageAction.action);
    writer.writeEnumValue<CalendarSharingActionType>("actionType", calendarSharingMessageAction.actionType);
    writer.writeEnumValue<CalendarSharingActionImportance>("importance", calendarSharingMessageAction.importance);
    writer.writeStringValue("@odata.type", calendarSharingMessageAction.odataType);
    writer.writeAdditionalData(calendarSharingMessageAction.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCallEndedEventMessageDetail(writer: SerializationWriter, callEndedEventMessageDetail: Partial<CallEndedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, callEndedEventMessageDetail)
    writer.writeDurationValue("callDuration", callEndedEventMessageDetail.callDuration);
    writer.writeEnumValue<TeamworkCallEventType>("callEventType", callEndedEventMessageDetail.callEventType);
    writer.writeStringValue("callId", callEndedEventMessageDetail.callId);
    writer.writeCollectionOfObjectValues<CallParticipantInfo>("callParticipants", callEndedEventMessageDetail.callParticipants, serializeCallParticipantInfo);
    writer.writeObjectValue<IdentitySet>("initiator", callEndedEventMessageDetail.initiator, serializeIdentitySet);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCallParticipantInfo(writer: SerializationWriter, callParticipantInfo: Partial<CallParticipantInfo> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", callParticipantInfo.odataType);
    writer.writeObjectValue<IdentitySet>("participant", callParticipantInfo.participant, serializeIdentitySet);
    writer.writeAdditionalData(callParticipantInfo.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCallRecordingEventMessageDetail(writer: SerializationWriter, callRecordingEventMessageDetail: Partial<CallRecordingEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, callRecordingEventMessageDetail)
    writer.writeStringValue("callId", callRecordingEventMessageDetail.callId);
    writer.writeStringValue("callRecordingDisplayName", callRecordingEventMessageDetail.callRecordingDisplayName);
    writer.writeDurationValue("callRecordingDuration", callRecordingEventMessageDetail.callRecordingDuration);
    writer.writeEnumValue<CallRecordingStatus>("callRecordingStatus", callRecordingEventMessageDetail.callRecordingStatus);
    writer.writeStringValue("callRecordingUrl", callRecordingEventMessageDetail.callRecordingUrl);
    writer.writeObjectValue<IdentitySet>("initiator", callRecordingEventMessageDetail.initiator, serializeIdentitySet);
    writer.writeObjectValue<IdentitySet>("meetingOrganizer", callRecordingEventMessageDetail.meetingOrganizer, serializeIdentitySet);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCallStartedEventMessageDetail(writer: SerializationWriter, callStartedEventMessageDetail: Partial<CallStartedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, callStartedEventMessageDetail)
    writer.writeEnumValue<TeamworkCallEventType>("callEventType", callStartedEventMessageDetail.callEventType);
    writer.writeStringValue("callId", callStartedEventMessageDetail.callId);
    writer.writeObjectValue<IdentitySet>("initiator", callStartedEventMessageDetail.initiator, serializeIdentitySet);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCallTranscriptEventMessageDetail(writer: SerializationWriter, callTranscriptEventMessageDetail: Partial<CallTranscriptEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, callTranscriptEventMessageDetail)
    writer.writeStringValue("callId", callTranscriptEventMessageDetail.callId);
    writer.writeStringValue("callTranscriptICalUid", callTranscriptEventMessageDetail.callTranscriptICalUid);
    writer.writeObjectValue<IdentitySet>("meetingOrganizer", callTranscriptEventMessageDetail.meetingOrganizer, serializeIdentitySet);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChannelAddedEventMessageDetail(writer: SerializationWriter, channelAddedEventMessageDetail: Partial<ChannelAddedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, channelAddedEventMessageDetail)
    writer.writeStringValue("channelDisplayName", channelAddedEventMessageDetail.channelDisplayName);
    writer.writeStringValue("channelId", channelAddedEventMessageDetail.channelId);
    writer.writeObjectValue<IdentitySet>("initiator", channelAddedEventMessageDetail.initiator, serializeIdentitySet);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChannelDeletedEventMessageDetail(writer: SerializationWriter, channelDeletedEventMessageDetail: Partial<ChannelDeletedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, channelDeletedEventMessageDetail)
    writer.writeStringValue("channelDisplayName", channelDeletedEventMessageDetail.channelDisplayName);
    writer.writeStringValue("channelId", channelDeletedEventMessageDetail.channelId);
    writer.writeObjectValue<IdentitySet>("initiator", channelDeletedEventMessageDetail.initiator, serializeIdentitySet);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChannelDescriptionUpdatedEventMessageDetail(writer: SerializationWriter, channelDescriptionUpdatedEventMessageDetail: Partial<ChannelDescriptionUpdatedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, channelDescriptionUpdatedEventMessageDetail)
    writer.writeStringValue("channelDescription", channelDescriptionUpdatedEventMessageDetail.channelDescription);
    writer.writeStringValue("channelId", channelDescriptionUpdatedEventMessageDetail.channelId);
    writer.writeObjectValue<IdentitySet>("initiator", channelDescriptionUpdatedEventMessageDetail.initiator, serializeIdentitySet);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChannelIdentity(writer: SerializationWriter, channelIdentity: Partial<ChannelIdentity> | undefined = {}) : void {
    writer.writeStringValue("channelId", channelIdentity.channelId);
    writer.writeStringValue("@odata.type", channelIdentity.odataType);
    writer.writeStringValue("teamId", channelIdentity.teamId);
    writer.writeAdditionalData(channelIdentity.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChannelRenamedEventMessageDetail(writer: SerializationWriter, channelRenamedEventMessageDetail: Partial<ChannelRenamedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, channelRenamedEventMessageDetail)
    writer.writeStringValue("channelDisplayName", channelRenamedEventMessageDetail.channelDisplayName);
    writer.writeStringValue("channelId", channelRenamedEventMessageDetail.channelId);
    writer.writeObjectValue<IdentitySet>("initiator", channelRenamedEventMessageDetail.initiator, serializeIdentitySet);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChannelSetAsFavoriteByDefaultEventMessageDetail(writer: SerializationWriter, channelSetAsFavoriteByDefaultEventMessageDetail: Partial<ChannelSetAsFavoriteByDefaultEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, channelSetAsFavoriteByDefaultEventMessageDetail)
    writer.writeStringValue("channelId", channelSetAsFavoriteByDefaultEventMessageDetail.channelId);
    writer.writeObjectValue<IdentitySet>("initiator", channelSetAsFavoriteByDefaultEventMessageDetail.initiator, serializeIdentitySet);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChannelUnsetAsFavoriteByDefaultEventMessageDetail(writer: SerializationWriter, channelUnsetAsFavoriteByDefaultEventMessageDetail: Partial<ChannelUnsetAsFavoriteByDefaultEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, channelUnsetAsFavoriteByDefaultEventMessageDetail)
    writer.writeStringValue("channelId", channelUnsetAsFavoriteByDefaultEventMessageDetail.channelId);
    writer.writeObjectValue<IdentitySet>("initiator", channelUnsetAsFavoriteByDefaultEventMessageDetail.initiator, serializeIdentitySet);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChatMessage(writer: SerializationWriter, chatMessage: Partial<ChatMessage> | undefined = {}) : void {
    serializeEntity(writer, chatMessage)
    writer.writeCollectionOfObjectValues<ChatMessageAttachment>("attachments", chatMessage.attachments, serializeChatMessageAttachment);
    writer.writeObjectValue<ItemBody>("body", chatMessage.body, serializeItemBody);
    writer.writeObjectValue<ChannelIdentity>("channelIdentity", chatMessage.channelIdentity, serializeChannelIdentity);
    writer.writeStringValue("chatId", chatMessage.chatId);
    writer.writeDateValue("createdDateTime", chatMessage.createdDateTime);
    writer.writeDateValue("deletedDateTime", chatMessage.deletedDateTime);
    writer.writeStringValue("etag", chatMessage.etag);
    writer.writeObjectValue<EventMessageDetail>("eventDetail", chatMessage.eventDetail, serializeEventMessageDetail);
    writer.writeObjectValue<ChatMessageFromIdentitySet>("from", chatMessage.from, serializeChatMessageFromIdentitySet);
    writer.writeCollectionOfObjectValues<ChatMessageHostedContent>("hostedContents", chatMessage.hostedContents, serializeChatMessageHostedContent);
    writer.writeEnumValue<ChatMessageImportance>("importance", chatMessage.importance);
    writer.writeDateValue("lastEditedDateTime", chatMessage.lastEditedDateTime);
    writer.writeDateValue("lastModifiedDateTime", chatMessage.lastModifiedDateTime);
    writer.writeStringValue("locale", chatMessage.locale);
    writer.writeCollectionOfObjectValues<ChatMessageMention>("mentions", chatMessage.mentions, serializeChatMessageMention);
    writer.writeCollectionOfObjectValues<ChatMessageHistoryItem>("messageHistory", chatMessage.messageHistory, serializeChatMessageHistoryItem);
    writer.writeEnumValue<ChatMessageType>("messageType", chatMessage.messageType);
    writer.writeObjectValue<ChatMessagePolicyViolation>("policyViolation", chatMessage.policyViolation, serializeChatMessagePolicyViolation);
    writer.writeCollectionOfObjectValues<ChatMessageReaction>("reactions", chatMessage.reactions, serializeChatMessageReaction);
    writer.writeCollectionOfObjectValues<ChatMessage>("replies", chatMessage.replies, serializeChatMessage);
    writer.writeStringValue("replyToId", chatMessage.replyToId);
    writer.writeStringValue("subject", chatMessage.subject);
    writer.writeStringValue("summary", chatMessage.summary);
    writer.writeStringValue("webUrl", chatMessage.webUrl);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChatMessageAttachment(writer: SerializationWriter, chatMessageAttachment: Partial<ChatMessageAttachment> | undefined = {}) : void {
    writer.writeStringValue("content", chatMessageAttachment.content);
    writer.writeStringValue("contentType", chatMessageAttachment.contentType);
    writer.writeStringValue("contentUrl", chatMessageAttachment.contentUrl);
    writer.writeStringValue("id", chatMessageAttachment.id);
    writer.writeStringValue("name", chatMessageAttachment.name);
    writer.writeStringValue("@odata.type", chatMessageAttachment.odataType);
    writer.writeStringValue("teamsAppId", chatMessageAttachment.teamsAppId);
    writer.writeStringValue("thumbnailUrl", chatMessageAttachment.thumbnailUrl);
    writer.writeAdditionalData(chatMessageAttachment.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChatMessageCollectionResponse(writer: SerializationWriter, chatMessageCollectionResponse: Partial<ChatMessageCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, chatMessageCollectionResponse)
    writer.writeCollectionOfObjectValues<ChatMessage>("value", chatMessageCollectionResponse.value, serializeChatMessage);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChatMessageFromIdentitySet(writer: SerializationWriter, chatMessageFromIdentitySet: Partial<ChatMessageFromIdentitySet> | undefined = {}) : void {
    serializeIdentitySet(writer, chatMessageFromIdentitySet)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChatMessageHistoryItem(writer: SerializationWriter, chatMessageHistoryItem: Partial<ChatMessageHistoryItem> | undefined = {}) : void {
    writer.writeEnumValue<ChatMessageActions[]>("actions", chatMessageHistoryItem.actions);
    writer.writeDateValue("modifiedDateTime", chatMessageHistoryItem.modifiedDateTime);
    writer.writeStringValue("@odata.type", chatMessageHistoryItem.odataType);
    writer.writeObjectValue<ChatMessageReaction>("reaction", chatMessageHistoryItem.reaction, serializeChatMessageReaction);
    writer.writeAdditionalData(chatMessageHistoryItem.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChatMessageHostedContent(writer: SerializationWriter, chatMessageHostedContent: Partial<ChatMessageHostedContent> | undefined = {}) : void {
    serializeTeamworkHostedContent(writer, chatMessageHostedContent)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChatMessageMention(writer: SerializationWriter, chatMessageMention: Partial<ChatMessageMention> | undefined = {}) : void {
    writer.writeNumberValue("id", chatMessageMention.id);
    writer.writeObjectValue<ChatMessageMentionedIdentitySet>("mentioned", chatMessageMention.mentioned, serializeChatMessageMentionedIdentitySet);
    writer.writeStringValue("mentionText", chatMessageMention.mentionText);
    writer.writeStringValue("@odata.type", chatMessageMention.odataType);
    writer.writeAdditionalData(chatMessageMention.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChatMessageMentionedIdentitySet(writer: SerializationWriter, chatMessageMentionedIdentitySet: Partial<ChatMessageMentionedIdentitySet> | undefined = {}) : void {
    serializeIdentitySet(writer, chatMessageMentionedIdentitySet)
    writer.writeObjectValue<TeamworkConversationIdentity>("conversation", chatMessageMentionedIdentitySet.conversation, serializeTeamworkConversationIdentity);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChatMessagePolicyViolation(writer: SerializationWriter, chatMessagePolicyViolation: Partial<ChatMessagePolicyViolation> | undefined = {}) : void {
    writer.writeEnumValue<ChatMessagePolicyViolationDlpActionTypes[]>("dlpAction", chatMessagePolicyViolation.dlpAction);
    writer.writeStringValue("justificationText", chatMessagePolicyViolation.justificationText);
    writer.writeStringValue("@odata.type", chatMessagePolicyViolation.odataType);
    writer.writeObjectValue<ChatMessagePolicyViolationPolicyTip>("policyTip", chatMessagePolicyViolation.policyTip, serializeChatMessagePolicyViolationPolicyTip);
    writer.writeEnumValue<ChatMessagePolicyViolationUserActionTypes[]>("userAction", chatMessagePolicyViolation.userAction);
    writer.writeEnumValue<ChatMessagePolicyViolationVerdictDetailsTypes[]>("verdictDetails", chatMessagePolicyViolation.verdictDetails);
    writer.writeAdditionalData(chatMessagePolicyViolation.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChatMessagePolicyViolationPolicyTip(writer: SerializationWriter, chatMessagePolicyViolationPolicyTip: Partial<ChatMessagePolicyViolationPolicyTip> | undefined = {}) : void {
    writer.writeStringValue("complianceUrl", chatMessagePolicyViolationPolicyTip.complianceUrl);
    writer.writeStringValue("generalText", chatMessagePolicyViolationPolicyTip.generalText);
    writer.writeCollectionOfPrimitiveValues<string>("matchedConditionDescriptions", chatMessagePolicyViolationPolicyTip.matchedConditionDescriptions);
    writer.writeStringValue("@odata.type", chatMessagePolicyViolationPolicyTip.odataType);
    writer.writeAdditionalData(chatMessagePolicyViolationPolicyTip.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChatMessageReaction(writer: SerializationWriter, chatMessageReaction: Partial<ChatMessageReaction> | undefined = {}) : void {
    writer.writeDateValue("createdDateTime", chatMessageReaction.createdDateTime);
    writer.writeStringValue("@odata.type", chatMessageReaction.odataType);
    writer.writeStringValue("reactionType", chatMessageReaction.reactionType);
    writer.writeObjectValue<ChatMessageReactionIdentitySet>("user", chatMessageReaction.user, serializeChatMessageReactionIdentitySet);
    writer.writeAdditionalData(chatMessageReaction.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChatMessageReactionIdentitySet(writer: SerializationWriter, chatMessageReactionIdentitySet: Partial<ChatMessageReactionIdentitySet> | undefined = {}) : void {
    serializeIdentitySet(writer, chatMessageReactionIdentitySet)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeChatRenamedEventMessageDetail(writer: SerializationWriter, chatRenamedEventMessageDetail: Partial<ChatRenamedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, chatRenamedEventMessageDetail)
    writer.writeStringValue("chatDisplayName", chatRenamedEventMessageDetail.chatDisplayName);
    writer.writeStringValue("chatId", chatRenamedEventMessageDetail.chatId);
    writer.writeObjectValue<IdentitySet>("initiator", chatRenamedEventMessageDetail.initiator, serializeIdentitySet);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCommunicationsApplicationIdentity(writer: SerializationWriter, communicationsApplicationIdentity: Partial<CommunicationsApplicationIdentity> | undefined = {}) : void {
    serializeIdentity(writer, communicationsApplicationIdentity)
    writer.writeStringValue("applicationType", communicationsApplicationIdentity.applicationType);
    writer.writeBooleanValue("hidden", communicationsApplicationIdentity.hidden);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCommunicationsApplicationInstanceIdentity(writer: SerializationWriter, communicationsApplicationInstanceIdentity: Partial<CommunicationsApplicationInstanceIdentity> | undefined = {}) : void {
    serializeIdentity(writer, communicationsApplicationInstanceIdentity)
    writer.writeBooleanValue("hidden", communicationsApplicationInstanceIdentity.hidden);
    writer.writeStringValue("tenantId", communicationsApplicationInstanceIdentity.tenantId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCommunicationsEncryptedIdentity(writer: SerializationWriter, communicationsEncryptedIdentity: Partial<CommunicationsEncryptedIdentity> | undefined = {}) : void {
    serializeIdentity(writer, communicationsEncryptedIdentity)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCommunicationsGuestIdentity(writer: SerializationWriter, communicationsGuestIdentity: Partial<CommunicationsGuestIdentity> | undefined = {}) : void {
    serializeIdentity(writer, communicationsGuestIdentity)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCommunicationsIdentitySet(writer: SerializationWriter, communicationsIdentitySet: Partial<CommunicationsIdentitySet> | undefined = {}) : void {
    serializeIdentitySet(writer, communicationsIdentitySet)
    writer.writeObjectValue<Identity>("applicationInstance", communicationsIdentitySet.applicationInstance, serializeIdentity);
    writer.writeObjectValue<Identity>("assertedIdentity", communicationsIdentitySet.assertedIdentity, serializeIdentity);
    writer.writeObjectValue<Identity>("azureCommunicationServicesUser", communicationsIdentitySet.azureCommunicationServicesUser, serializeIdentity);
    writer.writeObjectValue<Identity>("encrypted", communicationsIdentitySet.encrypted, serializeIdentity);
    writer.writeEnumValue<EndpointType>("endpointType", communicationsIdentitySet.endpointType);
    writer.writeObjectValue<Identity>("guest", communicationsIdentitySet.guest, serializeIdentity);
    writer.writeObjectValue<Identity>("onPremises", communicationsIdentitySet.onPremises, serializeIdentity);
    writer.writeObjectValue<Identity>("phone", communicationsIdentitySet.phone, serializeIdentity);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCommunicationsPhoneIdentity(writer: SerializationWriter, communicationsPhoneIdentity: Partial<CommunicationsPhoneIdentity> | undefined = {}) : void {
    serializeIdentity(writer, communicationsPhoneIdentity)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeCommunicationsUserIdentity(writer: SerializationWriter, communicationsUserIdentity: Partial<CommunicationsUserIdentity> | undefined = {}) : void {
    serializeIdentity(writer, communicationsUserIdentity)
    writer.writeStringValue("tenantId", communicationsUserIdentity.tenantId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeContact(writer: SerializationWriter, contact: Partial<Contact> | undefined = {}) : void {
    serializeOutlookItem(writer, contact)
    writer.writeStringValue("assistantName", contact.assistantName);
    writer.writeDateValue("birthday", contact.birthday);
    writer.writeObjectValue<PhysicalAddress>("businessAddress", contact.businessAddress, serializePhysicalAddress);
    writer.writeStringValue("businessHomePage", contact.businessHomePage);
    writer.writeCollectionOfPrimitiveValues<string>("businessPhones", contact.businessPhones);
    writer.writeCollectionOfPrimitiveValues<string>("children", contact.children);
    writer.writeStringValue("companyName", contact.companyName);
    writer.writeStringValue("department", contact.department);
    writer.writeStringValue("displayName", contact.displayName);
    writer.writeCollectionOfObjectValues<EmailAddress>("emailAddresses", contact.emailAddresses, serializeEmailAddress);
    writer.writeCollectionOfObjectValues<Extension>("extensions", contact.extensions, serializeExtension);
    writer.writeStringValue("fileAs", contact.fileAs);
    writer.writeStringValue("generation", contact.generation);
    writer.writeStringValue("givenName", contact.givenName);
    writer.writeObjectValue<PhysicalAddress>("homeAddress", contact.homeAddress, serializePhysicalAddress);
    writer.writeCollectionOfPrimitiveValues<string>("homePhones", contact.homePhones);
    writer.writeCollectionOfPrimitiveValues<string>("imAddresses", contact.imAddresses);
    writer.writeStringValue("initials", contact.initials);
    writer.writeStringValue("jobTitle", contact.jobTitle);
    writer.writeStringValue("manager", contact.manager);
    writer.writeStringValue("middleName", contact.middleName);
    writer.writeStringValue("mobilePhone", contact.mobilePhone);
    writer.writeCollectionOfObjectValues<MultiValueLegacyExtendedProperty>("multiValueExtendedProperties", contact.multiValueExtendedProperties, serializeMultiValueLegacyExtendedProperty);
    writer.writeStringValue("nickName", contact.nickName);
    writer.writeStringValue("officeLocation", contact.officeLocation);
    writer.writeObjectValue<PhysicalAddress>("otherAddress", contact.otherAddress, serializePhysicalAddress);
    writer.writeStringValue("parentFolderId", contact.parentFolderId);
    writer.writeStringValue("personalNotes", contact.personalNotes);
    writer.writeObjectValue<ProfilePhoto>("photo", contact.photo, serializeProfilePhoto);
    writer.writeStringValue("profession", contact.profession);
    writer.writeCollectionOfObjectValues<SingleValueLegacyExtendedProperty>("singleValueExtendedProperties", contact.singleValueExtendedProperties, serializeSingleValueLegacyExtendedProperty);
    writer.writeStringValue("spouseName", contact.spouseName);
    writer.writeStringValue("surname", contact.surname);
    writer.writeStringValue("title", contact.title);
    writer.writeStringValue("yomiCompanyName", contact.yomiCompanyName);
    writer.writeStringValue("yomiGivenName", contact.yomiGivenName);
    writer.writeStringValue("yomiSurname", contact.yomiSurname);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeConversationMemberRoleUpdatedEventMessageDetail(writer: SerializationWriter, conversationMemberRoleUpdatedEventMessageDetail: Partial<ConversationMemberRoleUpdatedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, conversationMemberRoleUpdatedEventMessageDetail)
    writer.writeCollectionOfPrimitiveValues<string>("conversationMemberRoles", conversationMemberRoleUpdatedEventMessageDetail.conversationMemberRoles);
    writer.writeObjectValue<TeamworkUserIdentity>("conversationMemberUser", conversationMemberRoleUpdatedEventMessageDetail.conversationMemberUser, serializeTeamworkUserIdentity);
    writer.writeObjectValue<IdentitySet>("initiator", conversationMemberRoleUpdatedEventMessageDetail.initiator, serializeIdentitySet);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDateTimeTimeZone(writer: SerializationWriter, dateTimeTimeZone: Partial<DateTimeTimeZone> | undefined = {}) : void {
    writer.writeStringValue("dateTime", dateTimeTimeZone.dateTime);
    writer.writeStringValue("@odata.type", dateTimeTimeZone.odataType);
    writer.writeStringValue("timeZone", dateTimeTimeZone.timeZone);
    writer.writeAdditionalData(dateTimeTimeZone.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeDetailsInfo(writer: SerializationWriter, detailsInfo: Partial<DetailsInfo> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", detailsInfo.odataType);
    writer.writeAdditionalData(detailsInfo.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEmailAddress(writer: SerializationWriter, emailAddress: Partial<EmailAddress> | undefined = {}) : void {
    writer.writeStringValue("address", emailAddress.address);
    writer.writeStringValue("name", emailAddress.name);
    writer.writeStringValue("@odata.type", emailAddress.odataType);
    writer.writeAdditionalData(emailAddress.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEmailIdentity(writer: SerializationWriter, emailIdentity: Partial<EmailIdentity> | undefined = {}) : void {
    serializeIdentity(writer, emailIdentity)
    writer.writeStringValue("email", emailIdentity.email);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEntity(writer: SerializationWriter, entity: Partial<Entity> | undefined = {}) : void {
    writer.writeStringValue("id", entity.id);
    writer.writeStringValue("@odata.type", entity.odataType);
    writer.writeAdditionalData(entity.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEvent(writer: SerializationWriter, event: Partial<Event> | undefined = {}) : void {
    serializeOutlookItem(writer, event)
    writer.writeBooleanValue("allowNewTimeProposals", event.allowNewTimeProposals);
    writer.writeCollectionOfObjectValues<Attachment>("attachments", event.attachments, serializeAttachment);
    writer.writeCollectionOfObjectValues<Attendee>("attendees", event.attendees, serializeAttendee);
    writer.writeObjectValue<ItemBody>("body", event.body, serializeItemBody);
    writer.writeStringValue("bodyPreview", event.bodyPreview);
    writer.writeObjectValue<Calendar>("calendar", event.calendar, serializeCalendar);
    writer.writeObjectValue<DateTimeTimeZone>("end", event.end, serializeDateTimeTimeZone);
    writer.writeCollectionOfObjectValues<Extension>("extensions", event.extensions, serializeExtension);
    writer.writeBooleanValue("hasAttachments", event.hasAttachments);
    writer.writeBooleanValue("hideAttendees", event.hideAttendees);
    writer.writeStringValue("iCalUId", event.iCalUId);
    writer.writeEnumValue<Importance>("importance", event.importance);
    writer.writeCollectionOfObjectValues<Event>("instances", event.instances, serializeEvent);
    writer.writeBooleanValue("isAllDay", event.isAllDay);
    writer.writeBooleanValue("isCancelled", event.isCancelled);
    writer.writeBooleanValue("isDraft", event.isDraft);
    writer.writeBooleanValue("isOnlineMeeting", event.isOnlineMeeting);
    writer.writeBooleanValue("isOrganizer", event.isOrganizer);
    writer.writeBooleanValue("isReminderOn", event.isReminderOn);
    writer.writeObjectValue<Location>("location", event.location, serializeLocation);
    writer.writeCollectionOfObjectValues<Location>("locations", event.locations, serializeLocation);
    writer.writeCollectionOfObjectValues<MultiValueLegacyExtendedProperty>("multiValueExtendedProperties", event.multiValueExtendedProperties, serializeMultiValueLegacyExtendedProperty);
    writer.writeObjectValue<OnlineMeetingInfo>("onlineMeeting", event.onlineMeeting, serializeOnlineMeetingInfo);
    writer.writeEnumValue<OnlineMeetingProviderType>("onlineMeetingProvider", event.onlineMeetingProvider);
    writer.writeStringValue("onlineMeetingUrl", event.onlineMeetingUrl);
    writer.writeObjectValue<Recipient>("organizer", event.organizer, serializeRecipient);
    writer.writeStringValue("originalEndTimeZone", event.originalEndTimeZone);
    writer.writeDateValue("originalStart", event.originalStart);
    writer.writeStringValue("originalStartTimeZone", event.originalStartTimeZone);
    writer.writeObjectValue<PatternedRecurrence>("recurrence", event.recurrence, serializePatternedRecurrence);
    writer.writeNumberValue("reminderMinutesBeforeStart", event.reminderMinutesBeforeStart);
    writer.writeBooleanValue("responseRequested", event.responseRequested);
    writer.writeObjectValue<ResponseStatus>("responseStatus", event.responseStatus, serializeResponseStatus);
    writer.writeEnumValue<Sensitivity>("sensitivity", event.sensitivity);
    writer.writeStringValue("seriesMasterId", event.seriesMasterId);
    writer.writeEnumValue<FreeBusyStatus>("showAs", event.showAs);
    writer.writeCollectionOfObjectValues<SingleValueLegacyExtendedProperty>("singleValueExtendedProperties", event.singleValueExtendedProperties, serializeSingleValueLegacyExtendedProperty);
    writer.writeObjectValue<DateTimeTimeZone>("start", event.start, serializeDateTimeTimeZone);
    writer.writeStringValue("subject", event.subject);
    writer.writeStringValue("transactionId", event.transactionId);
    writer.writeEnumValue<EventType>("type", event.type);
    writer.writeStringValue("webLink", event.webLink);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEventMessage(writer: SerializationWriter, eventMessage: Partial<EventMessage> | undefined = {}) : void {
    serializeMessage(writer, eventMessage)
    writer.writeObjectValue<DateTimeTimeZone>("endDateTime", eventMessage.endDateTime, serializeDateTimeTimeZone);
    writer.writeObjectValue<Event>("event", eventMessage.event, serializeEvent);
    writer.writeBooleanValue("isAllDay", eventMessage.isAllDay);
    writer.writeBooleanValue("isDelegated", eventMessage.isDelegated);
    writer.writeBooleanValue("isOutOfDate", eventMessage.isOutOfDate);
    writer.writeObjectValue<Location>("location", eventMessage.location, serializeLocation);
    writer.writeEnumValue<MeetingMessageType>("meetingMessageType", eventMessage.meetingMessageType);
    writer.writeObjectValue<PatternedRecurrence>("recurrence", eventMessage.recurrence, serializePatternedRecurrence);
    writer.writeObjectValue<DateTimeTimeZone>("startDateTime", eventMessage.startDateTime, serializeDateTimeTimeZone);
    writer.writeEnumValue<EventType>("type", eventMessage.type);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEventMessageDetail(writer: SerializationWriter, eventMessageDetail: Partial<EventMessageDetail> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", eventMessageDetail.odataType);
    writer.writeAdditionalData(eventMessageDetail.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEventMessageRequest(writer: SerializationWriter, eventMessageRequest: Partial<EventMessageRequest> | undefined = {}) : void {
    serializeEventMessage(writer, eventMessageRequest)
    writer.writeBooleanValue("allowNewTimeProposals", eventMessageRequest.allowNewTimeProposals);
    writer.writeEnumValue<MeetingRequestType>("meetingRequestType", eventMessageRequest.meetingRequestType);
    writer.writeObjectValue<DateTimeTimeZone>("previousEndDateTime", eventMessageRequest.previousEndDateTime, serializeDateTimeTimeZone);
    writer.writeObjectValue<Location>("previousLocation", eventMessageRequest.previousLocation, serializeLocation);
    writer.writeObjectValue<DateTimeTimeZone>("previousStartDateTime", eventMessageRequest.previousStartDateTime, serializeDateTimeTimeZone);
    writer.writeBooleanValue("responseRequested", eventMessageRequest.responseRequested);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeEventMessageResponse(writer: SerializationWriter, eventMessageResponse: Partial<EventMessageResponse> | undefined = {}) : void {
    serializeEventMessage(writer, eventMessageResponse)
    writer.writeObjectValue<TimeSlot>("proposedNewTime", eventMessageResponse.proposedNewTime, serializeTimeSlot);
    writer.writeEnumValue<ResponseType>("responseType", eventMessageResponse.responseType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeExtension(writer: SerializationWriter, extension: Partial<Extension> | undefined = {}) : void {
    serializeEntity(writer, extension)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFileAttachment(writer: SerializationWriter, fileAttachment: Partial<FileAttachment> | undefined = {}) : void {
    serializeAttachment(writer, fileAttachment)
    writer.writeStringValue("contentBytes", fileAttachment.contentBytes);
    writer.writeStringValue("contentId", fileAttachment.contentId);
    writer.writeStringValue("contentLocation", fileAttachment.contentLocation);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeFollowupFlag(writer: SerializationWriter, followupFlag: Partial<FollowupFlag> | undefined = {}) : void {
    writer.writeObjectValue<DateTimeTimeZone>("completedDateTime", followupFlag.completedDateTime, serializeDateTimeTimeZone);
    writer.writeObjectValue<DateTimeTimeZone>("dueDateTime", followupFlag.dueDateTime, serializeDateTimeTimeZone);
    writer.writeEnumValue<FollowupFlagStatus>("flagStatus", followupFlag.flagStatus);
    writer.writeStringValue("@odata.type", followupFlag.odataType);
    writer.writeObjectValue<DateTimeTimeZone>("startDateTime", followupFlag.startDateTime, serializeDateTimeTimeZone);
    writer.writeAdditionalData(followupFlag.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIdentity(writer: SerializationWriter, identity: Partial<Identity> | undefined = {}) : void {
    writer.writeStringValue("displayName", identity.displayName);
    writer.writeStringValue("id", identity.id);
    writer.writeStringValue("@odata.type", identity.odataType);
    writer.writeAdditionalData(identity.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeIdentitySet(writer: SerializationWriter, identitySet: Partial<IdentitySet> | undefined = {}) : void {
    writer.writeObjectValue<Identity>("application", identitySet.application, serializeIdentity);
    writer.writeObjectValue<Identity>("device", identitySet.device, serializeIdentity);
    writer.writeStringValue("@odata.type", identitySet.odataType);
    writer.writeObjectValue<Identity>("user", identitySet.user, serializeIdentity);
    writer.writeAdditionalData(identitySet.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeInitiator(writer: SerializationWriter, initiator: Partial<Initiator> | undefined = {}) : void {
    serializeIdentity(writer, initiator)
    writer.writeEnumValue<InitiatorType>("initiatorType", initiator.initiatorType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeInternetMessageHeader(writer: SerializationWriter, internetMessageHeader: Partial<InternetMessageHeader> | undefined = {}) : void {
    writer.writeStringValue("name", internetMessageHeader.name);
    writer.writeStringValue("@odata.type", internetMessageHeader.odataType);
    writer.writeStringValue("value", internetMessageHeader.value);
    writer.writeAdditionalData(internetMessageHeader.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeItemAttachment(writer: SerializationWriter, itemAttachment: Partial<ItemAttachment> | undefined = {}) : void {
    serializeAttachment(writer, itemAttachment)
    writer.writeObjectValue<OutlookItem>("item", itemAttachment.item, serializeOutlookItem);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeItemBody(writer: SerializationWriter, itemBody: Partial<ItemBody> | undefined = {}) : void {
    writer.writeStringValue("content", itemBody.content);
    writer.writeEnumValue<BodyType>("contentType", itemBody.contentType);
    writer.writeStringValue("@odata.type", itemBody.odataType);
    writer.writeAdditionalData(itemBody.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeLocation(writer: SerializationWriter, location: Partial<Location> | undefined = {}) : void {
    writer.writeObjectValue<PhysicalAddress>("address", location.address, serializePhysicalAddress);
    writer.writeObjectValue<OutlookGeoCoordinates>("coordinates", location.coordinates, serializeOutlookGeoCoordinates);
    writer.writeStringValue("displayName", location.displayName);
    writer.writeStringValue("locationEmailAddress", location.locationEmailAddress);
    writer.writeEnumValue<LocationType>("locationType", location.locationType);
    writer.writeStringValue("locationUri", location.locationUri);
    writer.writeStringValue("@odata.type", location.odataType);
    writer.writeStringValue("uniqueId", location.uniqueId);
    writer.writeEnumValue<LocationUniqueIdType>("uniqueIdType", location.uniqueIdType);
    writer.writeAdditionalData(location.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeLocationConstraintItem(writer: SerializationWriter, locationConstraintItem: Partial<LocationConstraintItem> | undefined = {}) : void {
    serializeLocation(writer, locationConstraintItem)
    writer.writeBooleanValue("resolveAvailability", locationConstraintItem.resolveAvailability);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMailFolder(writer: SerializationWriter, mailFolder: Partial<MailFolder> | undefined = {}) : void {
    serializeEntity(writer, mailFolder)
    writer.writeNumberValue("childFolderCount", mailFolder.childFolderCount);
    writer.writeCollectionOfObjectValues<MailFolder>("childFolders", mailFolder.childFolders, serializeMailFolder);
    writer.writeStringValue("displayName", mailFolder.displayName);
    writer.writeBooleanValue("isHidden", mailFolder.isHidden);
    writer.writeCollectionOfObjectValues<MessageRule>("messageRules", mailFolder.messageRules, serializeMessageRule);
    writer.writeCollectionOfObjectValues<Message>("messages", mailFolder.messages, serializeMessage);
    writer.writeCollectionOfObjectValues<MultiValueLegacyExtendedProperty>("multiValueExtendedProperties", mailFolder.multiValueExtendedProperties, serializeMultiValueLegacyExtendedProperty);
    writer.writeStringValue("parentFolderId", mailFolder.parentFolderId);
    writer.writeCollectionOfObjectValues<SingleValueLegacyExtendedProperty>("singleValueExtendedProperties", mailFolder.singleValueExtendedProperties, serializeSingleValueLegacyExtendedProperty);
    writer.writeNumberValue("totalItemCount", mailFolder.totalItemCount);
    writer.writeNumberValue("unreadItemCount", mailFolder.unreadItemCount);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMailFolderCollectionResponse(writer: SerializationWriter, mailFolderCollectionResponse: Partial<MailFolderCollectionResponse> | undefined = {}) : void {
    serializeBaseCollectionPaginationCountResponse(writer, mailFolderCollectionResponse)
    writer.writeCollectionOfObjectValues<MailFolder>("value", mailFolderCollectionResponse.value, serializeMailFolder);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMailSearchFolder(writer: SerializationWriter, mailSearchFolder: Partial<MailSearchFolder> | undefined = {}) : void {
    serializeMailFolder(writer, mailSearchFolder)
    writer.writeStringValue("filterQuery", mailSearchFolder.filterQuery);
    writer.writeBooleanValue("includeNestedFolders", mailSearchFolder.includeNestedFolders);
    writer.writeBooleanValue("isSupported", mailSearchFolder.isSupported);
    writer.writeCollectionOfPrimitiveValues<string>("sourceFolderIds", mailSearchFolder.sourceFolderIds);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMeetingPolicyUpdatedEventMessageDetail(writer: SerializationWriter, meetingPolicyUpdatedEventMessageDetail: Partial<MeetingPolicyUpdatedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, meetingPolicyUpdatedEventMessageDetail)
    writer.writeObjectValue<IdentitySet>("initiator", meetingPolicyUpdatedEventMessageDetail.initiator, serializeIdentitySet);
    writer.writeBooleanValue("meetingChatEnabled", meetingPolicyUpdatedEventMessageDetail.meetingChatEnabled);
    writer.writeStringValue("meetingChatId", meetingPolicyUpdatedEventMessageDetail.meetingChatId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMembersAddedEventMessageDetail(writer: SerializationWriter, membersAddedEventMessageDetail: Partial<MembersAddedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, membersAddedEventMessageDetail)
    writer.writeObjectValue<IdentitySet>("initiator", membersAddedEventMessageDetail.initiator, serializeIdentitySet);
    writer.writeCollectionOfObjectValues<TeamworkUserIdentity>("members", membersAddedEventMessageDetail.members, serializeTeamworkUserIdentity);
    writer.writeDateValue("visibleHistoryStartDateTime", membersAddedEventMessageDetail.visibleHistoryStartDateTime);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMembersDeletedEventMessageDetail(writer: SerializationWriter, membersDeletedEventMessageDetail: Partial<MembersDeletedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, membersDeletedEventMessageDetail)
    writer.writeObjectValue<IdentitySet>("initiator", membersDeletedEventMessageDetail.initiator, serializeIdentitySet);
    writer.writeCollectionOfObjectValues<TeamworkUserIdentity>("members", membersDeletedEventMessageDetail.members, serializeTeamworkUserIdentity);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMembersJoinedEventMessageDetail(writer: SerializationWriter, membersJoinedEventMessageDetail: Partial<MembersJoinedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, membersJoinedEventMessageDetail)
    writer.writeObjectValue<IdentitySet>("initiator", membersJoinedEventMessageDetail.initiator, serializeIdentitySet);
    writer.writeCollectionOfObjectValues<TeamworkUserIdentity>("members", membersJoinedEventMessageDetail.members, serializeTeamworkUserIdentity);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMembersLeftEventMessageDetail(writer: SerializationWriter, membersLeftEventMessageDetail: Partial<MembersLeftEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, membersLeftEventMessageDetail)
    writer.writeObjectValue<IdentitySet>("initiator", membersLeftEventMessageDetail.initiator, serializeIdentitySet);
    writer.writeCollectionOfObjectValues<TeamworkUserIdentity>("members", membersLeftEventMessageDetail.members, serializeTeamworkUserIdentity);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMessage(writer: SerializationWriter, message: Partial<Message> | undefined = {}) : void {
    serializeOutlookItem(writer, message)
    writer.writeCollectionOfObjectValues<Attachment>("attachments", message.attachments, serializeAttachment);
    writer.writeCollectionOfObjectValues<Recipient>("bccRecipients", message.bccRecipients, serializeRecipient);
    writer.writeObjectValue<ItemBody>("body", message.body, serializeItemBody);
    writer.writeStringValue("bodyPreview", message.bodyPreview);
    writer.writeCollectionOfObjectValues<Recipient>("ccRecipients", message.ccRecipients, serializeRecipient);
    writer.writeStringValue("conversationId", message.conversationId);
    writer.writeStringValue("conversationIndex", message.conversationIndex);
    writer.writeCollectionOfObjectValues<Extension>("extensions", message.extensions, serializeExtension);
    writer.writeObjectValue<FollowupFlag>("flag", message.flag, serializeFollowupFlag);
    writer.writeObjectValue<Recipient>("from", message.from, serializeRecipient);
    writer.writeBooleanValue("hasAttachments", message.hasAttachments);
    writer.writeEnumValue<Importance>("importance", message.importance);
    writer.writeEnumValue<InferenceClassificationType>("inferenceClassification", message.inferenceClassification);
    writer.writeCollectionOfObjectValues<InternetMessageHeader>("internetMessageHeaders", message.internetMessageHeaders, serializeInternetMessageHeader);
    writer.writeStringValue("internetMessageId", message.internetMessageId);
    writer.writeBooleanValue("isDeliveryReceiptRequested", message.isDeliveryReceiptRequested);
    writer.writeBooleanValue("isDraft", message.isDraft);
    writer.writeBooleanValue("isRead", message.isRead);
    writer.writeBooleanValue("isReadReceiptRequested", message.isReadReceiptRequested);
    writer.writeCollectionOfObjectValues<MultiValueLegacyExtendedProperty>("multiValueExtendedProperties", message.multiValueExtendedProperties, serializeMultiValueLegacyExtendedProperty);
    writer.writeStringValue("parentFolderId", message.parentFolderId);
    writer.writeDateValue("receivedDateTime", message.receivedDateTime);
    writer.writeCollectionOfObjectValues<Recipient>("replyTo", message.replyTo, serializeRecipient);
    writer.writeObjectValue<Recipient>("sender", message.sender, serializeRecipient);
    writer.writeDateValue("sentDateTime", message.sentDateTime);
    writer.writeCollectionOfObjectValues<SingleValueLegacyExtendedProperty>("singleValueExtendedProperties", message.singleValueExtendedProperties, serializeSingleValueLegacyExtendedProperty);
    writer.writeStringValue("subject", message.subject);
    writer.writeCollectionOfObjectValues<Recipient>("toRecipients", message.toRecipients, serializeRecipient);
    writer.writeObjectValue<ItemBody>("uniqueBody", message.uniqueBody, serializeItemBody);
    writer.writeStringValue("webLink", message.webLink);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMessagePinnedEventMessageDetail(writer: SerializationWriter, messagePinnedEventMessageDetail: Partial<MessagePinnedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, messagePinnedEventMessageDetail)
    writer.writeDateValue("eventDateTime", messagePinnedEventMessageDetail.eventDateTime);
    writer.writeObjectValue<IdentitySet>("initiator", messagePinnedEventMessageDetail.initiator, serializeIdentitySet);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMessageRule(writer: SerializationWriter, messageRule: Partial<MessageRule> | undefined = {}) : void {
    serializeEntity(writer, messageRule)
    writer.writeObjectValue<MessageRuleActions>("actions", messageRule.actions, serializeMessageRuleActions);
    writer.writeObjectValue<MessageRulePredicates>("conditions", messageRule.conditions, serializeMessageRulePredicates);
    writer.writeStringValue("displayName", messageRule.displayName);
    writer.writeObjectValue<MessageRulePredicates>("exceptions", messageRule.exceptions, serializeMessageRulePredicates);
    writer.writeBooleanValue("hasError", messageRule.hasError);
    writer.writeBooleanValue("isEnabled", messageRule.isEnabled);
    writer.writeBooleanValue("isReadOnly", messageRule.isReadOnly);
    writer.writeNumberValue("sequence", messageRule.sequence);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMessageRuleActions(writer: SerializationWriter, messageRuleActions: Partial<MessageRuleActions> | undefined = {}) : void {
    writer.writeCollectionOfPrimitiveValues<string>("assignCategories", messageRuleActions.assignCategories);
    writer.writeStringValue("copyToFolder", messageRuleActions.copyToFolder);
    writer.writeBooleanValue("delete", messageRuleActions.delete);
    writer.writeCollectionOfObjectValues<Recipient>("forwardAsAttachmentTo", messageRuleActions.forwardAsAttachmentTo, serializeRecipient);
    writer.writeCollectionOfObjectValues<Recipient>("forwardTo", messageRuleActions.forwardTo, serializeRecipient);
    writer.writeBooleanValue("markAsRead", messageRuleActions.markAsRead);
    writer.writeEnumValue<Importance>("markImportance", messageRuleActions.markImportance);
    writer.writeStringValue("moveToFolder", messageRuleActions.moveToFolder);
    writer.writeStringValue("@odata.type", messageRuleActions.odataType);
    writer.writeBooleanValue("permanentDelete", messageRuleActions.permanentDelete);
    writer.writeCollectionOfObjectValues<Recipient>("redirectTo", messageRuleActions.redirectTo, serializeRecipient);
    writer.writeBooleanValue("stopProcessingRules", messageRuleActions.stopProcessingRules);
    writer.writeAdditionalData(messageRuleActions.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMessageRulePredicates(writer: SerializationWriter, messageRulePredicates: Partial<MessageRulePredicates> | undefined = {}) : void {
    writer.writeCollectionOfPrimitiveValues<string>("bodyContains", messageRulePredicates.bodyContains);
    writer.writeCollectionOfPrimitiveValues<string>("bodyOrSubjectContains", messageRulePredicates.bodyOrSubjectContains);
    writer.writeCollectionOfPrimitiveValues<string>("categories", messageRulePredicates.categories);
    writer.writeCollectionOfObjectValues<Recipient>("fromAddresses", messageRulePredicates.fromAddresses, serializeRecipient);
    writer.writeBooleanValue("hasAttachments", messageRulePredicates.hasAttachments);
    writer.writeCollectionOfPrimitiveValues<string>("headerContains", messageRulePredicates.headerContains);
    writer.writeEnumValue<Importance>("importance", messageRulePredicates.importance);
    writer.writeBooleanValue("isApprovalRequest", messageRulePredicates.isApprovalRequest);
    writer.writeBooleanValue("isAutomaticForward", messageRulePredicates.isAutomaticForward);
    writer.writeBooleanValue("isAutomaticReply", messageRulePredicates.isAutomaticReply);
    writer.writeBooleanValue("isEncrypted", messageRulePredicates.isEncrypted);
    writer.writeBooleanValue("isMeetingRequest", messageRulePredicates.isMeetingRequest);
    writer.writeBooleanValue("isMeetingResponse", messageRulePredicates.isMeetingResponse);
    writer.writeBooleanValue("isNonDeliveryReport", messageRulePredicates.isNonDeliveryReport);
    writer.writeBooleanValue("isPermissionControlled", messageRulePredicates.isPermissionControlled);
    writer.writeBooleanValue("isReadReceipt", messageRulePredicates.isReadReceipt);
    writer.writeBooleanValue("isSigned", messageRulePredicates.isSigned);
    writer.writeBooleanValue("isVoicemail", messageRulePredicates.isVoicemail);
    writer.writeEnumValue<MessageActionFlag>("messageActionFlag", messageRulePredicates.messageActionFlag);
    writer.writeBooleanValue("notSentToMe", messageRulePredicates.notSentToMe);
    writer.writeStringValue("@odata.type", messageRulePredicates.odataType);
    writer.writeCollectionOfPrimitiveValues<string>("recipientContains", messageRulePredicates.recipientContains);
    writer.writeCollectionOfPrimitiveValues<string>("senderContains", messageRulePredicates.senderContains);
    writer.writeEnumValue<Sensitivity>("sensitivity", messageRulePredicates.sensitivity);
    writer.writeBooleanValue("sentCcMe", messageRulePredicates.sentCcMe);
    writer.writeBooleanValue("sentOnlyToMe", messageRulePredicates.sentOnlyToMe);
    writer.writeCollectionOfObjectValues<Recipient>("sentToAddresses", messageRulePredicates.sentToAddresses, serializeRecipient);
    writer.writeBooleanValue("sentToMe", messageRulePredicates.sentToMe);
    writer.writeBooleanValue("sentToOrCcMe", messageRulePredicates.sentToOrCcMe);
    writer.writeCollectionOfPrimitiveValues<string>("subjectContains", messageRulePredicates.subjectContains);
    writer.writeObjectValue<SizeRange>("withinSizeRange", messageRulePredicates.withinSizeRange, serializeSizeRange);
    writer.writeAdditionalData(messageRulePredicates.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMessageUnpinnedEventMessageDetail(writer: SerializationWriter, messageUnpinnedEventMessageDetail: Partial<MessageUnpinnedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, messageUnpinnedEventMessageDetail)
    writer.writeDateValue("eventDateTime", messageUnpinnedEventMessageDetail.eventDateTime);
    writer.writeObjectValue<IdentitySet>("initiator", messageUnpinnedEventMessageDetail.initiator, serializeIdentitySet);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeMultiValueLegacyExtendedProperty(writer: SerializationWriter, multiValueLegacyExtendedProperty: Partial<MultiValueLegacyExtendedProperty> | undefined = {}) : void {
    serializeEntity(writer, multiValueLegacyExtendedProperty)
    writer.writeCollectionOfPrimitiveValues<string>("value", multiValueLegacyExtendedProperty.value);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeOnlineMeetingInfo(writer: SerializationWriter, onlineMeetingInfo: Partial<OnlineMeetingInfo> | undefined = {}) : void {
    writer.writeStringValue("conferenceId", onlineMeetingInfo.conferenceId);
    writer.writeStringValue("joinUrl", onlineMeetingInfo.joinUrl);
    writer.writeStringValue("@odata.type", onlineMeetingInfo.odataType);
    writer.writeCollectionOfObjectValues<Phone>("phones", onlineMeetingInfo.phones, serializePhone);
    writer.writeStringValue("quickDial", onlineMeetingInfo.quickDial);
    writer.writeCollectionOfPrimitiveValues<string>("tollFreeNumbers", onlineMeetingInfo.tollFreeNumbers);
    writer.writeStringValue("tollNumber", onlineMeetingInfo.tollNumber);
    writer.writeAdditionalData(onlineMeetingInfo.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeOpenTypeExtension(writer: SerializationWriter, openTypeExtension: Partial<OpenTypeExtension> | undefined = {}) : void {
    serializeExtension(writer, openTypeExtension)
    writer.writeStringValue("extensionName", openTypeExtension.extensionName);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeOutlookGeoCoordinates(writer: SerializationWriter, outlookGeoCoordinates: Partial<OutlookGeoCoordinates> | undefined = {}) : void {
    writer.writeNumberValue("accuracy", outlookGeoCoordinates.accuracy);
    writer.writeNumberValue("altitude", outlookGeoCoordinates.altitude);
    writer.writeNumberValue("altitudeAccuracy", outlookGeoCoordinates.altitudeAccuracy);
    writer.writeNumberValue("latitude", outlookGeoCoordinates.latitude);
    writer.writeNumberValue("longitude", outlookGeoCoordinates.longitude);
    writer.writeStringValue("@odata.type", outlookGeoCoordinates.odataType);
    writer.writeAdditionalData(outlookGeoCoordinates.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeOutlookItem(writer: SerializationWriter, outlookItem: Partial<OutlookItem> | undefined = {}) : void {
    serializeEntity(writer, outlookItem)
    writer.writeCollectionOfPrimitiveValues<string>("categories", outlookItem.categories);
    writer.writeStringValue("changeKey", outlookItem.changeKey);
    writer.writeDateValue("createdDateTime", outlookItem.createdDateTime);
    writer.writeDateValue("lastModifiedDateTime", outlookItem.lastModifiedDateTime);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializePatternedRecurrence(writer: SerializationWriter, patternedRecurrence: Partial<PatternedRecurrence> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", patternedRecurrence.odataType);
    writer.writeObjectValue<RecurrencePattern>("pattern", patternedRecurrence.pattern, serializeRecurrencePattern);
    writer.writeObjectValue<RecurrenceRange>("range", patternedRecurrence.range, serializeRecurrenceRange);
    writer.writeAdditionalData(patternedRecurrence.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializePhone(writer: SerializationWriter, phone: Partial<Phone> | undefined = {}) : void {
    writer.writeStringValue("language", phone.language);
    writer.writeStringValue("number", phone.number);
    writer.writeStringValue("@odata.type", phone.odataType);
    writer.writeStringValue("region", phone.region);
    writer.writeEnumValue<PhoneType>("type", phone.type);
    writer.writeAdditionalData(phone.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializePhysicalAddress(writer: SerializationWriter, physicalAddress: Partial<PhysicalAddress> | undefined = {}) : void {
    writer.writeStringValue("city", physicalAddress.city);
    writer.writeStringValue("countryOrRegion", physicalAddress.countryOrRegion);
    writer.writeStringValue("@odata.type", physicalAddress.odataType);
    writer.writeStringValue("postalCode", physicalAddress.postalCode);
    writer.writeStringValue("state", physicalAddress.state);
    writer.writeStringValue("street", physicalAddress.street);
    writer.writeAdditionalData(physicalAddress.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializePost(writer: SerializationWriter, post: Partial<Post> | undefined = {}) : void {
    serializeOutlookItem(writer, post)
    writer.writeCollectionOfObjectValues<Attachment>("attachments", post.attachments, serializeAttachment);
    writer.writeObjectValue<ItemBody>("body", post.body, serializeItemBody);
    writer.writeStringValue("conversationId", post.conversationId);
    writer.writeStringValue("conversationThreadId", post.conversationThreadId);
    writer.writeCollectionOfObjectValues<Extension>("extensions", post.extensions, serializeExtension);
    writer.writeObjectValue<Recipient>("from", post.from, serializeRecipient);
    writer.writeBooleanValue("hasAttachments", post.hasAttachments);
    writer.writeObjectValue<Post>("inReplyTo", post.inReplyTo, serializePost);
    writer.writeCollectionOfObjectValues<MultiValueLegacyExtendedProperty>("multiValueExtendedProperties", post.multiValueExtendedProperties, serializeMultiValueLegacyExtendedProperty);
    writer.writeCollectionOfObjectValues<Recipient>("newParticipants", post.newParticipants, serializeRecipient);
    writer.writeDateValue("receivedDateTime", post.receivedDateTime);
    writer.writeObjectValue<Recipient>("sender", post.sender, serializeRecipient);
    writer.writeCollectionOfObjectValues<SingleValueLegacyExtendedProperty>("singleValueExtendedProperties", post.singleValueExtendedProperties, serializeSingleValueLegacyExtendedProperty);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeProfilePhoto(writer: SerializationWriter, profilePhoto: Partial<ProfilePhoto> | undefined = {}) : void {
    serializeEntity(writer, profilePhoto)
    writer.writeNumberValue("height", profilePhoto.height);
    writer.writeNumberValue("width", profilePhoto.width);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeProvisionedIdentity(writer: SerializationWriter, provisionedIdentity: Partial<ProvisionedIdentity> | undefined = {}) : void {
    serializeIdentity(writer, provisionedIdentity)
    writer.writeObjectValue<DetailsInfo>("details", provisionedIdentity.details, serializeDetailsInfo);
    writer.writeStringValue("identityType", provisionedIdentity.identityType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeProvisioningServicePrincipal(writer: SerializationWriter, provisioningServicePrincipal: Partial<ProvisioningServicePrincipal> | undefined = {}) : void {
    serializeIdentity(writer, provisioningServicePrincipal)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeProvisioningSystem(writer: SerializationWriter, provisioningSystem: Partial<ProvisioningSystem> | undefined = {}) : void {
    serializeIdentity(writer, provisioningSystem)
    writer.writeObjectValue<DetailsInfo>("details", provisioningSystem.details, serializeDetailsInfo);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRecipient(writer: SerializationWriter, recipient: Partial<Recipient> | undefined = {}) : void {
    writer.writeObjectValue<EmailAddress>("emailAddress", recipient.emailAddress, serializeEmailAddress);
    writer.writeStringValue("@odata.type", recipient.odataType);
    writer.writeAdditionalData(recipient.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRecurrencePattern(writer: SerializationWriter, recurrencePattern: Partial<RecurrencePattern> | undefined = {}) : void {
    writer.writeNumberValue("dayOfMonth", recurrencePattern.dayOfMonth);
    if(recurrencePattern.daysOfWeek)
    writer.writeEnumValue<DayOfWeek>("daysOfWeek", ...recurrencePattern.daysOfWeek);
    writer.writeEnumValue<DayOfWeek>("firstDayOfWeek", recurrencePattern.firstDayOfWeek);
    writer.writeEnumValue<WeekIndex>("index", recurrencePattern.index);
    writer.writeNumberValue("interval", recurrencePattern.interval);
    writer.writeNumberValue("month", recurrencePattern.month);
    writer.writeStringValue("@odata.type", recurrencePattern.odataType);
    writer.writeEnumValue<RecurrencePatternType>("type", recurrencePattern.type);
    writer.writeAdditionalData(recurrencePattern.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeRecurrenceRange(writer: SerializationWriter, recurrenceRange: Partial<RecurrenceRange> | undefined = {}) : void {
    writer.writeDateOnlyValue("endDate", recurrenceRange.endDate);
    writer.writeNumberValue("numberOfOccurrences", recurrenceRange.numberOfOccurrences);
    writer.writeStringValue("@odata.type", recurrenceRange.odataType);
    writer.writeStringValue("recurrenceTimeZone", recurrenceRange.recurrenceTimeZone);
    writer.writeDateOnlyValue("startDate", recurrenceRange.startDate);
    writer.writeEnumValue<RecurrenceRangeType>("type", recurrenceRange.type);
    writer.writeAdditionalData(recurrenceRange.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeReferenceAttachment(writer: SerializationWriter, referenceAttachment: Partial<ReferenceAttachment> | undefined = {}) : void {
    serializeAttachment(writer, referenceAttachment)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeResponseStatus(writer: SerializationWriter, responseStatus: Partial<ResponseStatus> | undefined = {}) : void {
    writer.writeStringValue("@odata.type", responseStatus.odataType);
    writer.writeEnumValue<ResponseType>("response", responseStatus.response);
    writer.writeDateValue("time", responseStatus.time);
    writer.writeAdditionalData(responseStatus.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeServicePrincipalIdentity(writer: SerializationWriter, servicePrincipalIdentity: Partial<ServicePrincipalIdentity> | undefined = {}) : void {
    serializeIdentity(writer, servicePrincipalIdentity)
    writer.writeStringValue("appId", servicePrincipalIdentity.appId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSharePointIdentity(writer: SerializationWriter, sharePointIdentity: Partial<SharePointIdentity> | undefined = {}) : void {
    serializeIdentity(writer, sharePointIdentity)
    writer.writeStringValue("loginName", sharePointIdentity.loginName);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSharePointIdentitySet(writer: SerializationWriter, sharePointIdentitySet: Partial<SharePointIdentitySet> | undefined = {}) : void {
    serializeIdentitySet(writer, sharePointIdentitySet)
    writer.writeObjectValue<Identity>("group", sharePointIdentitySet.group, serializeIdentity);
    writer.writeObjectValue<SharePointIdentity>("siteGroup", sharePointIdentitySet.siteGroup, serializeSharePointIdentity);
    writer.writeObjectValue<SharePointIdentity>("siteUser", sharePointIdentitySet.siteUser, serializeSharePointIdentity);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSingleValueLegacyExtendedProperty(writer: SerializationWriter, singleValueLegacyExtendedProperty: Partial<SingleValueLegacyExtendedProperty> | undefined = {}) : void {
    serializeEntity(writer, singleValueLegacyExtendedProperty)
    writer.writeStringValue("value", singleValueLegacyExtendedProperty.value);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeSizeRange(writer: SerializationWriter, sizeRange: Partial<SizeRange> | undefined = {}) : void {
    writer.writeNumberValue("maximumSize", sizeRange.maximumSize);
    writer.writeNumberValue("minimumSize", sizeRange.minimumSize);
    writer.writeStringValue("@odata.type", sizeRange.odataType);
    writer.writeAdditionalData(sizeRange.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTabUpdatedEventMessageDetail(writer: SerializationWriter, tabUpdatedEventMessageDetail: Partial<TabUpdatedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, tabUpdatedEventMessageDetail)
    writer.writeObjectValue<IdentitySet>("initiator", tabUpdatedEventMessageDetail.initiator, serializeIdentitySet);
    writer.writeStringValue("tabId", tabUpdatedEventMessageDetail.tabId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTeamArchivedEventMessageDetail(writer: SerializationWriter, teamArchivedEventMessageDetail: Partial<TeamArchivedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, teamArchivedEventMessageDetail)
    writer.writeObjectValue<IdentitySet>("initiator", teamArchivedEventMessageDetail.initiator, serializeIdentitySet);
    writer.writeStringValue("teamId", teamArchivedEventMessageDetail.teamId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTeamCreatedEventMessageDetail(writer: SerializationWriter, teamCreatedEventMessageDetail: Partial<TeamCreatedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, teamCreatedEventMessageDetail)
    writer.writeObjectValue<IdentitySet>("initiator", teamCreatedEventMessageDetail.initiator, serializeIdentitySet);
    writer.writeStringValue("teamDescription", teamCreatedEventMessageDetail.teamDescription);
    writer.writeStringValue("teamDisplayName", teamCreatedEventMessageDetail.teamDisplayName);
    writer.writeStringValue("teamId", teamCreatedEventMessageDetail.teamId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTeamDescriptionUpdatedEventMessageDetail(writer: SerializationWriter, teamDescriptionUpdatedEventMessageDetail: Partial<TeamDescriptionUpdatedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, teamDescriptionUpdatedEventMessageDetail)
    writer.writeObjectValue<IdentitySet>("initiator", teamDescriptionUpdatedEventMessageDetail.initiator, serializeIdentitySet);
    writer.writeStringValue("teamDescription", teamDescriptionUpdatedEventMessageDetail.teamDescription);
    writer.writeStringValue("teamId", teamDescriptionUpdatedEventMessageDetail.teamId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTeamJoiningDisabledEventMessageDetail(writer: SerializationWriter, teamJoiningDisabledEventMessageDetail: Partial<TeamJoiningDisabledEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, teamJoiningDisabledEventMessageDetail)
    writer.writeObjectValue<IdentitySet>("initiator", teamJoiningDisabledEventMessageDetail.initiator, serializeIdentitySet);
    writer.writeStringValue("teamId", teamJoiningDisabledEventMessageDetail.teamId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTeamJoiningEnabledEventMessageDetail(writer: SerializationWriter, teamJoiningEnabledEventMessageDetail: Partial<TeamJoiningEnabledEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, teamJoiningEnabledEventMessageDetail)
    writer.writeObjectValue<IdentitySet>("initiator", teamJoiningEnabledEventMessageDetail.initiator, serializeIdentitySet);
    writer.writeStringValue("teamId", teamJoiningEnabledEventMessageDetail.teamId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTeamRenamedEventMessageDetail(writer: SerializationWriter, teamRenamedEventMessageDetail: Partial<TeamRenamedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, teamRenamedEventMessageDetail)
    writer.writeObjectValue<IdentitySet>("initiator", teamRenamedEventMessageDetail.initiator, serializeIdentitySet);
    writer.writeStringValue("teamDisplayName", teamRenamedEventMessageDetail.teamDisplayName);
    writer.writeStringValue("teamId", teamRenamedEventMessageDetail.teamId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTeamsAppInstalledEventMessageDetail(writer: SerializationWriter, teamsAppInstalledEventMessageDetail: Partial<TeamsAppInstalledEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, teamsAppInstalledEventMessageDetail)
    writer.writeObjectValue<IdentitySet>("initiator", teamsAppInstalledEventMessageDetail.initiator, serializeIdentitySet);
    writer.writeStringValue("teamsAppDisplayName", teamsAppInstalledEventMessageDetail.teamsAppDisplayName);
    writer.writeStringValue("teamsAppId", teamsAppInstalledEventMessageDetail.teamsAppId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTeamsAppRemovedEventMessageDetail(writer: SerializationWriter, teamsAppRemovedEventMessageDetail: Partial<TeamsAppRemovedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, teamsAppRemovedEventMessageDetail)
    writer.writeObjectValue<IdentitySet>("initiator", teamsAppRemovedEventMessageDetail.initiator, serializeIdentitySet);
    writer.writeStringValue("teamsAppDisplayName", teamsAppRemovedEventMessageDetail.teamsAppDisplayName);
    writer.writeStringValue("teamsAppId", teamsAppRemovedEventMessageDetail.teamsAppId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTeamsAppUpgradedEventMessageDetail(writer: SerializationWriter, teamsAppUpgradedEventMessageDetail: Partial<TeamsAppUpgradedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, teamsAppUpgradedEventMessageDetail)
    writer.writeObjectValue<IdentitySet>("initiator", teamsAppUpgradedEventMessageDetail.initiator, serializeIdentitySet);
    writer.writeStringValue("teamsAppDisplayName", teamsAppUpgradedEventMessageDetail.teamsAppDisplayName);
    writer.writeStringValue("teamsAppId", teamsAppUpgradedEventMessageDetail.teamsAppId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTeamUnarchivedEventMessageDetail(writer: SerializationWriter, teamUnarchivedEventMessageDetail: Partial<TeamUnarchivedEventMessageDetail> | undefined = {}) : void {
    serializeEventMessageDetail(writer, teamUnarchivedEventMessageDetail)
    writer.writeObjectValue<IdentitySet>("initiator", teamUnarchivedEventMessageDetail.initiator, serializeIdentitySet);
    writer.writeStringValue("teamId", teamUnarchivedEventMessageDetail.teamId);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTeamworkApplicationIdentity(writer: SerializationWriter, teamworkApplicationIdentity: Partial<TeamworkApplicationIdentity> | undefined = {}) : void {
    serializeIdentity(writer, teamworkApplicationIdentity)
    writer.writeEnumValue<TeamworkApplicationIdentityType>("applicationIdentityType", teamworkApplicationIdentity.applicationIdentityType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTeamworkConversationIdentity(writer: SerializationWriter, teamworkConversationIdentity: Partial<TeamworkConversationIdentity> | undefined = {}) : void {
    serializeIdentity(writer, teamworkConversationIdentity)
    writer.writeEnumValue<TeamworkConversationIdentityType>("conversationIdentityType", teamworkConversationIdentity.conversationIdentityType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTeamworkHostedContent(writer: SerializationWriter, teamworkHostedContent: Partial<TeamworkHostedContent> | undefined = {}) : void {
    serializeEntity(writer, teamworkHostedContent)
    writer.writeStringValue("contentBytes", teamworkHostedContent.contentBytes);
    writer.writeStringValue("contentType", teamworkHostedContent.contentType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTeamworkTagIdentity(writer: SerializationWriter, teamworkTagIdentity: Partial<TeamworkTagIdentity> | undefined = {}) : void {
    serializeIdentity(writer, teamworkTagIdentity)
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTeamworkUserIdentity(writer: SerializationWriter, teamworkUserIdentity: Partial<TeamworkUserIdentity> | undefined = {}) : void {
    serializeIdentity(writer, teamworkUserIdentity)
    writer.writeEnumValue<TeamworkUserIdentityType>("userIdentityType", teamworkUserIdentity.userIdentityType);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeTimeSlot(writer: SerializationWriter, timeSlot: Partial<TimeSlot> | undefined = {}) : void {
    writer.writeObjectValue<DateTimeTimeZone>("end", timeSlot.end, serializeDateTimeTimeZone);
    writer.writeStringValue("@odata.type", timeSlot.odataType);
    writer.writeObjectValue<DateTimeTimeZone>("start", timeSlot.start, serializeDateTimeTimeZone);
    writer.writeAdditionalData(timeSlot.additionalData);
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
export function serializeUserIdentity(writer: SerializationWriter, userIdentity: Partial<UserIdentity> | undefined = {}) : void {
    serializeIdentity(writer, userIdentity)
    writer.writeStringValue("ipAddress", userIdentity.ipAddress);
    writer.writeStringValue("userPrincipalName", userIdentity.userPrincipalName);
}
export interface ServicePrincipalIdentity extends Identity, Parsable {
    /**
     * The application identifier of the service principal.
     */
    appId?: string;
}
export interface SharePointIdentity extends Identity, Parsable {
    /**
     * The sign in name of the SharePoint identity.
     */
    loginName?: string;
}
export interface SharePointIdentitySet extends IdentitySet, Parsable {
    /**
     * The group associated with this action. Optional.
     */
    group?: Identity;
    /**
     * The SharePoint group associated with this action. Optional.
     */
    siteGroup?: SharePointIdentity;
    /**
     * The SharePoint user associated with this action. Optional.
     */
    siteUser?: SharePointIdentity;
}
export interface SingleValueLegacyExtendedProperty extends Entity, Parsable {
    /**
     * A property value.
     */
    value?: string;
}
export interface SizeRange extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The maximum size (in kilobytes) that an incoming message must have in order for a condition or exception to apply.
     */
    maximumSize?: number;
    /**
     * The minimum size (in kilobytes) that an incoming message must have in order for a condition or exception to apply.
     */
    minimumSize?: number;
    /**
     * The OdataType property
     */
    odataType?: string;
}
export interface TabUpdatedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
    /**
     * Unique identifier of the tab.
     */
    tabId?: string;
}
export interface TeamArchivedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
    /**
     * Unique identifier of the team.
     */
    teamId?: string;
}
export interface TeamCreatedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
    /**
     * Description for the team.
     */
    teamDescription?: string;
    /**
     * Display name of the team.
     */
    teamDisplayName?: string;
    /**
     * Unique identifier of the team.
     */
    teamId?: string;
}
export interface TeamDescriptionUpdatedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
    /**
     * The updated description for the team.
     */
    teamDescription?: string;
    /**
     * Unique identifier of the team.
     */
    teamId?: string;
}
export interface TeamJoiningDisabledEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
    /**
     * Unique identifier of the team.
     */
    teamId?: string;
}
export interface TeamJoiningEnabledEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
    /**
     * Unique identifier of the team.
     */
    teamId?: string;
}
export interface TeamRenamedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
    /**
     * The updated name of the team.
     */
    teamDisplayName?: string;
    /**
     * Unique identifier of the team.
     */
    teamId?: string;
}
export interface TeamsAppInstalledEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
    /**
     * Display name of the teamsApp.
     */
    teamsAppDisplayName?: string;
    /**
     * Unique identifier of the teamsApp.
     */
    teamsAppId?: string;
}
export interface TeamsAppRemovedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
    /**
     * Display name of the teamsApp.
     */
    teamsAppDisplayName?: string;
    /**
     * Unique identifier of the teamsApp.
     */
    teamsAppId?: string;
}
export interface TeamsAppUpgradedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
    /**
     * Display name of the teamsApp.
     */
    teamsAppDisplayName?: string;
    /**
     * Unique identifier of the teamsApp.
     */
    teamsAppId?: string;
}
export interface TeamUnarchivedEventMessageDetail extends EventMessageDetail, Parsable {
    /**
     * Initiator of the event.
     */
    initiator?: IdentitySet;
    /**
     * Unique identifier of the team.
     */
    teamId?: string;
}
export interface TeamworkApplicationIdentity extends Identity, Parsable {
    /**
     * Type of application that is referenced. Possible values are: aadApplication, bot, tenantBot, office365Connector, outgoingWebhook, and unknownFutureValue.
     */
    applicationIdentityType?: TeamworkApplicationIdentityType;
}
export type TeamworkApplicationIdentityType = (typeof TeamworkApplicationIdentityTypeObject)[keyof typeof TeamworkApplicationIdentityTypeObject];
export type TeamworkCallEventType = (typeof TeamworkCallEventTypeObject)[keyof typeof TeamworkCallEventTypeObject];
export interface TeamworkConversationIdentity extends Identity, Parsable {
    /**
     * Type of conversation. Possible values are: team, channel, chat, and unknownFutureValue.
     */
    conversationIdentityType?: TeamworkConversationIdentityType;
}
export type TeamworkConversationIdentityType = (typeof TeamworkConversationIdentityTypeObject)[keyof typeof TeamworkConversationIdentityTypeObject];
export interface TeamworkHostedContent extends Entity, Parsable {
    /**
     * Write only. Bytes for the hosted content (such as images).
     */
    contentBytes?: string;
    /**
     * Write only. Content type. such as image/png, image/jpg.
     */
    contentType?: string;
}
export interface TeamworkTagIdentity extends Identity, Parsable {
}
export interface TeamworkUserIdentity extends Identity, Parsable {
    /**
     * Type of user. Possible values are: aadUser, onPremiseAadUser, anonymousGuest, federatedUser, personalMicrosoftAccountUser, skypeUser, phoneUser, unknownFutureValue and emailUser.
     */
    userIdentityType?: TeamworkUserIdentityType;
}
export type TeamworkUserIdentityType = (typeof TeamworkUserIdentityTypeObject)[keyof typeof TeamworkUserIdentityTypeObject];
export interface TimeSlot extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The end property
     */
    end?: DateTimeTimeZone;
    /**
     * The OdataType property
     */
    odataType?: string;
    /**
     * The start property
     */
    start?: DateTimeTimeZone;
}
export interface UserIdentity extends Identity, Parsable {
    /**
     * Indicates the client IP address associated with the user performing the activity (audit log only).
     */
    ipAddress?: string;
    /**
     * The userPrincipalName attribute of the user.
     */
    userPrincipalName?: string;
}
export type WeekIndex = (typeof WeekIndexObject)[keyof typeof WeekIndexObject];
export const AttendeeTypeObject = {
    Required: "required",
    Optional: "optional",
    Resource: "resource",
} as const;
export const BodyTypeObject = {
    Text: "text",
    Html: "html",
} as const;
export const CalendarColorObject = {
    Auto: "auto",
    LightBlue: "lightBlue",
    LightGreen: "lightGreen",
    LightOrange: "lightOrange",
    LightGray: "lightGray",
    LightYellow: "lightYellow",
    LightTeal: "lightTeal",
    LightPink: "lightPink",
    LightBrown: "lightBrown",
    LightRed: "lightRed",
    MaxColor: "maxColor",
} as const;
export const CalendarRoleTypeObject = {
    None: "none",
    FreeBusyRead: "freeBusyRead",
    LimitedRead: "limitedRead",
    Read: "read",
    Write: "write",
    DelegateWithoutPrivateEventAccess: "delegateWithoutPrivateEventAccess",
    DelegateWithPrivateEventAccess: "delegateWithPrivateEventAccess",
    Custom: "custom",
} as const;
export const CalendarSharingActionImportanceObject = {
    Primary: "primary",
    Secondary: "secondary",
} as const;
export const CalendarSharingActionObject = {
    Accept: "accept",
    AcceptAndViewCalendar: "acceptAndViewCalendar",
    ViewCalendar: "viewCalendar",
    AddThisCalendar: "addThisCalendar",
} as const;
export const CalendarSharingActionTypeObject = {
    Accept: "accept",
} as const;
export const CallRecordingStatusObject = {
    Success: "success",
    Failure: "failure",
    Initial: "initial",
    ChunkFinished: "chunkFinished",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ChatMessageActionsObject = {
    ReactionAdded: "reactionAdded",
    ReactionRemoved: "reactionRemoved",
    ActionUndefined: "actionUndefined",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ChatMessageImportanceObject = {
    Normal: "normal",
    High: "high",
    Urgent: "urgent",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const ChatMessagePolicyViolationDlpActionTypesObject = {
    None: "none",
    NotifySender: "notifySender",
    BlockAccess: "blockAccess",
    BlockAccessExternal: "blockAccessExternal",
} as const;
export const ChatMessagePolicyViolationUserActionTypesObject = {
    None: "none",
    Override: "override",
    ReportFalsePositive: "reportFalsePositive",
} as const;
export const ChatMessagePolicyViolationVerdictDetailsTypesObject = {
    None: "none",
    AllowFalsePositiveOverride: "allowFalsePositiveOverride",
    AllowOverrideWithoutJustification: "allowOverrideWithoutJustification",
    AllowOverrideWithJustification: "allowOverrideWithJustification",
} as const;
export const ChatMessageTypeObject = {
    Message: "message",
    ChatEvent: "chatEvent",
    Typing: "typing",
    UnknownFutureValue: "unknownFutureValue",
    SystemEventMessage: "systemEventMessage",
} as const;
export const DayOfWeekObject = {
    Sunday: "sunday",
    Monday: "monday",
    Tuesday: "tuesday",
    Wednesday: "wednesday",
    Thursday: "thursday",
    Friday: "friday",
    Saturday: "saturday",
} as const;
export const EndpointTypeObject = {
    DefaultEscaped: "default",
    Voicemail: "voicemail",
    SkypeForBusiness: "skypeForBusiness",
    SkypeForBusinessVoipPhone: "skypeForBusinessVoipPhone",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const EventTypeObject = {
    SingleInstance: "singleInstance",
    Occurrence: "occurrence",
    Exception: "exception",
    SeriesMaster: "seriesMaster",
} as const;
export const FollowupFlagStatusObject = {
    NotFlagged: "notFlagged",
    Complete: "complete",
    Flagged: "flagged",
} as const;
export const FreeBusyStatusObject = {
    Unknown: "unknown",
    Free: "free",
    Tentative: "tentative",
    Busy: "busy",
    Oof: "oof",
    WorkingElsewhere: "workingElsewhere",
} as const;
export const ImportanceObject = {
    Low: "low",
    Normal: "normal",
    High: "high",
} as const;
export const InferenceClassificationTypeObject = {
    Focused: "focused",
    Other: "other",
} as const;
export const InitiatorTypeObject = {
    User: "user",
    Application: "application",
    System: "system",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const LocationTypeObject = {
    DefaultEscaped: "default",
    ConferenceRoom: "conferenceRoom",
    HomeAddress: "homeAddress",
    BusinessAddress: "businessAddress",
    GeoCoordinates: "geoCoordinates",
    StreetAddress: "streetAddress",
    Hotel: "hotel",
    Restaurant: "restaurant",
    LocalBusiness: "localBusiness",
    PostalAddress: "postalAddress",
} as const;
export const LocationUniqueIdTypeObject = {
    Unknown: "unknown",
    LocationStore: "locationStore",
    Directory: "directory",
    Private: "private",
    Bing: "bing",
} as const;
export const MeetingMessageTypeObject = {
    None: "none",
    MeetingRequest: "meetingRequest",
    MeetingCancelled: "meetingCancelled",
    MeetingAccepted: "meetingAccepted",
    MeetingTenativelyAccepted: "meetingTenativelyAccepted",
    MeetingDeclined: "meetingDeclined",
} as const;
export const MeetingRequestTypeObject = {
    None: "none",
    NewMeetingRequest: "newMeetingRequest",
    FullUpdate: "fullUpdate",
    InformationalUpdate: "informationalUpdate",
    SilentUpdate: "silentUpdate",
    Outdated: "outdated",
    PrincipalWantsCopy: "principalWantsCopy",
} as const;
export const MessageActionFlagObject = {
    Any: "any",
    Call: "call",
    DoNotForward: "doNotForward",
    FollowUp: "followUp",
    Fyi: "fyi",
    Forward: "forward",
    NoResponseNecessary: "noResponseNecessary",
    Read: "read",
    Reply: "reply",
    ReplyToAll: "replyToAll",
    Review: "review",
} as const;
export const OnlineMeetingProviderTypeObject = {
    Unknown: "unknown",
    SkypeForBusiness: "skypeForBusiness",
    SkypeForConsumer: "skypeForConsumer",
    TeamsForBusiness: "teamsForBusiness",
} as const;
export const PhoneTypeObject = {
    Home: "home",
    Business: "business",
    Mobile: "mobile",
    Other: "other",
    Assistant: "assistant",
    HomeFax: "homeFax",
    BusinessFax: "businessFax",
    OtherFax: "otherFax",
    Pager: "pager",
    Radio: "radio",
} as const;
export const RecurrencePatternTypeObject = {
    Daily: "daily",
    Weekly: "weekly",
    AbsoluteMonthly: "absoluteMonthly",
    RelativeMonthly: "relativeMonthly",
    AbsoluteYearly: "absoluteYearly",
    RelativeYearly: "relativeYearly",
} as const;
export const RecurrenceRangeTypeObject = {
    EndDate: "endDate",
    NoEnd: "noEnd",
    Numbered: "numbered",
} as const;
export const ResponseTypeObject = {
    None: "none",
    Organizer: "organizer",
    TentativelyAccepted: "tentativelyAccepted",
    Accepted: "accepted",
    Declined: "declined",
    NotResponded: "notResponded",
} as const;
export const SensitivityObject = {
    Normal: "normal",
    Personal: "personal",
    Private: "private",
    Confidential: "confidential",
} as const;
export const TeamworkApplicationIdentityTypeObject = {
    AadApplication: "aadApplication",
    Bot: "bot",
    TenantBot: "tenantBot",
    Office365Connector: "office365Connector",
    OutgoingWebhook: "outgoingWebhook",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const TeamworkCallEventTypeObject = {
    Call: "call",
    Meeting: "meeting",
    ScreenShare: "screenShare",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const TeamworkConversationIdentityTypeObject = {
    Team: "team",
    Channel: "channel",
    Chat: "chat",
    UnknownFutureValue: "unknownFutureValue",
} as const;
export const TeamworkUserIdentityTypeObject = {
    AadUser: "aadUser",
    OnPremiseAadUser: "onPremiseAadUser",
    AnonymousGuest: "anonymousGuest",
    FederatedUser: "federatedUser",
    PersonalMicrosoftAccountUser: "personalMicrosoftAccountUser",
    SkypeUser: "skypeUser",
    PhoneUser: "phoneUser",
    UnknownFutureValue: "unknownFutureValue",
    EmailUser: "emailUser",
} as const;
export const WeekIndexObject = {
    First: "first",
    Second: "second",
    Third: "third",
    Fourth: "fourth",
    Last: "last",
} as const;
/* tslint:enable */
/* eslint-enable */
